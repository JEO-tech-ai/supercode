{
  "version": 3,
  "sources": ["../src/shared/logger.ts", "../src/services/agents/todo-manager.ts", "../src/core/hooks.ts", "../src/core/tools.ts", "../src/core/hooks/todo-continuation.ts", "../src/core/hooks/logging.ts", "../src/core/hooks/index.ts", "../src/core/tools/bash.ts", "../src/core/tools/file.ts", "../src/core/tools/search.ts", "../src/core/tools/todo.ts", "../src/core/tools/index.ts", "../src/services/auth/claude.ts", "../src/server/store/token-store.ts", "../src/services/auth/codex.ts", "../src/services/auth/gemini.ts", "../src/server/store/oauth-state-store.ts", "../node_modules/@hono/node-server/dist/index.mjs", "../src/server/index.ts", "../src/server/routes/index.ts", "../src/server/routes/health.ts", "../src/server/routes/auth-callback.ts", "../src/services/auth/hub.ts", "../src/shared/errors.ts", "../src/services/models/providers/anthropic.ts", "../src/services/models/providers/openai.ts", "../src/services/models/providers/google.ts", "../src/services/models/router.ts", "../src/services/agents/registry.ts", "../src/services/agents/index.ts", "../src/services/agents/background.ts", "../src/services/models/ai-sdk/registry.ts", "../src/services/models/ai-sdk/stream.ts", "../src/config/opencode.ts", "../src/services/agents/coin.ts", "../src/core/session.ts", "../src/services/agents/explorer.ts", "../src/services/agents/analyst.ts", "../src/services/agents/executor.ts", "../src/services/agents/code-reviewer.ts", "../src/services/agents/doc-writer.ts", "../src/core/index.ts", "../src/supercoin.ts"],
  "sourcesContent": ["/**\n * Logger Utility\n * Simple logging with debug support\n */\n\nconst DEBUG = process.env.SUPERCOIN_DEBUG === \"1\" || process.env.DEBUG === \"supercoin\";\n\nexport const logger = {\n  debug: (message: string, data?: unknown): void => {\n    if (DEBUG) {\n      console.debug(`[supercoin:debug] ${message}`, data ?? \"\");\n    }\n  },\n\n  info: (message: string): void => {\n    console.log(`[supercoin] ${message}`);\n  },\n\n  warn: (message: string): void => {\n    console.warn(`[supercoin:warn] ${message}`);\n  },\n\n  error: (message: string, error?: Error): void => {\n    console.error(`[supercoin:error] ${message}`);\n    if (error && DEBUG) {\n      console.error(error.stack);\n    }\n  },\n\n  success: (message: string): void => {\n    console.log(`[supercoin] ${message}`);\n  },\n};\n\nexport default logger;\n", "import type { Todo, TaskStatus } from \"./types\";\n\nexport interface ITodoManager {\n  create(input: { sessionId: string; content: string; priority?: \"high\" | \"medium\" | \"low\" }): Promise<Todo>;\n  updateStatus(id: string, status: TaskStatus): Promise<void>;\n  get(id: string): Todo | undefined;\n  list(sessionId?: string): Todo[];\n  listPending(sessionId?: string): Todo[];\n  hasPending(sessionId?: string): boolean;\n  clear(sessionId?: string): void;\n  // New: Support bulk update from todowrite tool\n  setTodos(sessionId: string, todos: Todo[]): void;\n}\n\nclass TodoManager implements ITodoManager {\n  private todos: Map<string, Todo> = new Map();\n\n  async create(input: { sessionId: string; content: string; priority?: \"high\" | \"medium\" | \"low\" }): Promise<Todo> {\n    const todo: Todo = {\n      id: crypto.randomUUID(),\n      sessionId: input.sessionId,\n      content: input.content,\n      status: \"pending\",\n      priority: input.priority || \"medium\",\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.todos.set(todo.id, todo);\n    return todo;\n  }\n\n  async updateStatus(id: string, status: TaskStatus): Promise<void> {\n    const todo = this.todos.get(id);\n    if (todo) {\n      todo.status = status;\n      todo.updatedAt = new Date();\n    }\n  }\n\n  get(id: string): Todo | undefined {\n    return this.todos.get(id);\n  }\n\n  list(sessionId?: string): Todo[] {\n    const allTodos = Array.from(this.todos.values());\n    if (sessionId) {\n      return allTodos.filter((t) => t.sessionId === sessionId);\n    }\n    return allTodos;\n  }\n\n  listPending(sessionId?: string): Todo[] {\n    return this.list(sessionId).filter((t) => t.status === \"pending\" || t.status === \"in_progress\");\n  }\n\n  hasPending(sessionId?: string): boolean {\n    return this.listPending(sessionId).length > 0;\n  }\n\n  clear(sessionId?: string): void {\n    if (sessionId) {\n      const toDelete = this.list(sessionId).map((t) => t.id);\n      for (const id of toDelete) {\n        this.todos.delete(id);\n      }\n    } else {\n      this.todos.clear();\n    }\n  }\n\n  setTodos(sessionId: string, todos: Todo[]): void {\n    this.clear(sessionId);\n    for (const todo of todos) {\n      this.todos.set(todo.id, { ...todo, sessionId });\n    }\n  }\n}\n\nlet todoManagerInstance: TodoManager | null = null;\n\nexport function getTodoManager(): ITodoManager {\n  if (!todoManagerInstance) {\n    todoManagerInstance = new TodoManager();\n  }\n  return todoManagerInstance;\n}\n", "import type { Hook, HookEvent, HookContext, HookResult } from \"./types\";\n\nexport interface IHookRegistry {\n  register(hook: Hook): void;\n  unregister(name: string): boolean;\n  get(name: string): Hook | undefined;\n  getForEvent(event: HookEvent): Hook[];\n  trigger(event: HookEvent, context: HookContext): Promise<HookResult | void>;\n  list(): Hook[];\n}\n\nclass HookRegistry implements IHookRegistry {\n  private hooks: Map<string, Hook> = new Map();\n\n  register(hook: Hook): void {\n    this.hooks.set(hook.name, hook);\n  }\n\n  unregister(name: string): boolean {\n    return this.hooks.delete(name);\n  }\n\n  get(name: string): Hook | undefined {\n    return this.hooks.get(name);\n  }\n\n  getForEvent(event: HookEvent): Hook[] {\n    return Array.from(this.hooks.values())\n      .filter((hook) => hook.events.includes(event))\n      .sort((a, b) => (b.priority || 0) - (a.priority || 0));\n  }\n\n  async trigger(event: HookEvent, context: HookContext): Promise<HookResult | void> {\n    const hooks = this.getForEvent(event);\n\n    for (const hook of hooks) {\n      try {\n        const result = await hook.handler(context);\n        if (result && result.continue === false) {\n          return result;\n        }\n      } catch (error) {\n        console.error(`Hook ${hook.name} failed:`, error);\n      }\n    }\n  }\n\n  list(): Hook[] {\n    return Array.from(this.hooks.values());\n  }\n}\n\nlet hookRegistryInstance: HookRegistry | null = null;\n\nexport function getHookRegistry(): IHookRegistry {\n  if (!hookRegistryInstance) {\n    hookRegistryInstance = new HookRegistry();\n  }\n  return hookRegistryInstance;\n}\n", "import type { ToolDefinition, ToolContext, ToolResult } from \"./types\";\n\nexport interface IToolRegistry {\n  register(tool: ToolDefinition): void;\n  unregister(name: string): boolean;\n  get(name: string): ToolDefinition | undefined;\n  execute(name: string, args: Record<string, unknown>, context: ToolContext): Promise<ToolResult>;\n  list(): ToolDefinition[];\n  listNames(): string[];\n}\n\nclass ToolRegistry implements IToolRegistry {\n  private tools: Map<string, ToolDefinition> = new Map();\n\n  register(tool: ToolDefinition): void {\n    this.tools.set(tool.name, tool);\n  }\n\n  unregister(name: string): boolean {\n    return this.tools.delete(name);\n  }\n\n  get(name: string): ToolDefinition | undefined {\n    return this.tools.get(name);\n  }\n\n  async execute(\n    name: string,\n    args: Record<string, unknown>,\n    context: ToolContext\n  ): Promise<ToolResult> {\n    const tool = this.tools.get(name);\n    if (!tool) {\n      return { success: false, error: `Tool not found: ${name}` };\n    }\n\n    try {\n      return await tool.execute(args, context);\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  }\n\n  list(): ToolDefinition[] {\n    return Array.from(this.tools.values());\n  }\n\n  listNames(): string[] {\n    return Array.from(this.tools.keys());\n  }\n}\n\nlet toolRegistryInstance: ToolRegistry | null = null;\n\nexport function getToolRegistry(): IToolRegistry {\n  if (!toolRegistryInstance) {\n    toolRegistryInstance = new ToolRegistry();\n  }\n  return toolRegistryInstance;\n}\n", "import type { Hook, HookContext } from \"../types\";\nimport { getTodoManager } from \"../../services/agents/todo-manager\";\n\nexport const todoContinuationHook: Hook = {\n  name: \"todo-continuation\",\n  events: [\"session.idle\"],\n  priority: 10,\n\n  async handler(context: HookContext) {\n    const todoManager = getTodoManager();\n\n    if (todoManager.hasPending()) {\n      const pending = todoManager.listPending();\n\n      return {\n        continue: true,\n        prompt: `There are ${pending.length} pending tasks:\\n${pending.map((t) => `- ${t.content}`).join(\"\\n\")}\\n\\nPlease continue working on the next pending task.`,\n      };\n    }\n\n    return { continue: false };\n  },\n};\n", "import type { Hook, HookContext } from \"../types\";\nimport logger from \"../../shared/logger\";\n\nexport const loggingHook: Hook = {\n  name: \"logging\",\n  events: [\"request.before\", \"request.after\", \"error\"],\n  priority: 100,\n\n  async handler(context: HookContext) {\n    switch (context.event) {\n      case \"request.before\":\n        logger.debug(`Request started in session ${context.sessionId}`);\n        break;\n\n      case \"request.after\":\n        logger.debug(`Request completed in session ${context.sessionId}`);\n        break;\n\n      case \"error\":\n        logger.error(`Error in session ${context.sessionId}`, context.data as Error);\n        break;\n    }\n  },\n};\n", "export { todoContinuationHook } from \"./todo-continuation\";\nexport { loggingHook } from \"./logging\";\n\nimport { getHookRegistry } from \"../hooks\";\nimport { todoContinuationHook } from \"./todo-continuation\";\nimport { loggingHook } from \"./logging\";\n\nexport function initializeHooks(): void {\n  const registry = getHookRegistry();\n\n  registry.register(todoContinuationHook);\n  registry.register(loggingHook);\n}\n", "import type { ToolDefinition, ToolContext, ToolResult } from \"../types\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nexport const bashTool: ToolDefinition = {\n  name: \"bash\",\n  description: \"Execute a bash command\",\n  parameters: [\n    {\n      name: \"command\",\n      type: \"string\",\n      description: \"The command to execute\",\n      required: true,\n    },\n    {\n      name: \"workdir\",\n      type: \"string\",\n      description: \"Working directory\",\n      required: false,\n    },\n    {\n      name: \"timeout\",\n      type: \"number\",\n      description: \"Timeout in milliseconds\",\n      required: false,\n      default: 120000,\n    },\n  ],\n\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    const command = args.command as string;\n    const workdir = (args.workdir as string) || context.workdir;\n    const timeout = (args.timeout as number) || 120000;\n\n    try {\n      const { stdout, stderr } = await execAsync(command, {\n        cwd: workdir,\n        timeout,\n        maxBuffer: 10 * 1024 * 1024,\n      });\n\n      return {\n        success: true,\n        output: stdout + (stderr ? `\\n${stderr}` : \"\"),\n      };\n    } catch (error) {\n      const execError = error as { stdout?: string; stderr?: string; message: string };\n      return {\n        success: false,\n        output: execError.stdout || \"\",\n        error: execError.stderr || execError.message,\n      };\n    }\n  },\n};\n", "import type { ToolDefinition, ToolContext, ToolResult } from \"../types\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\n\nexport const readTool: ToolDefinition = {\n  name: \"read\",\n  description: \"Read content from a file\",\n  parameters: [\n    {\n      name: \"filePath\",\n      type: \"string\",\n      description: \"The path to the file to read\",\n      required: true,\n    },\n    {\n      name: \"offset\",\n      type: \"number\",\n      description: \"Line number to start reading from (0-based)\",\n      required: false,\n    },\n    {\n      name: \"limit\",\n      type: \"number\",\n      description: \"Number of lines to read\",\n      required: false,\n    },\n  ],\n\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    const filePath = args.filePath as string;\n    const offset = (args.offset as number) || 0;\n    const limit = (args.limit as number) || 2000;\n\n    const resolvedPath = path.isAbsolute(filePath)\n      ? filePath\n      : path.resolve(context.workdir, filePath);\n\n    try {\n      const content = await fs.readFile(resolvedPath, \"utf-8\");\n      const lines = content.split(\"\\n\");\n      const selectedLines = lines.slice(offset, offset + limit);\n\n      const numberedContent = selectedLines\n        .map((line, index) => `${String(offset + index + 1).padStart(5)}| ${line}`)\n        .join(\"\\n\");\n\n      return {\n        success: true,\n        output: numberedContent,\n        data: { totalLines: lines.length, readLines: selectedLines.length },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n\nexport const writeTool: ToolDefinition = {\n  name: \"write\",\n  description: \"Write content to a file\",\n  parameters: [\n    {\n      name: \"filePath\",\n      type: \"string\",\n      description: \"The path to the file to write\",\n      required: true,\n    },\n    {\n      name: \"content\",\n      type: \"string\",\n      description: \"The content to write\",\n      required: true,\n    },\n  ],\n\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    const filePath = args.filePath as string;\n    const content = args.content as string;\n\n    const resolvedPath = path.isAbsolute(filePath)\n      ? filePath\n      : path.resolve(context.workdir, filePath);\n\n    try {\n      const dir = path.dirname(resolvedPath);\n      await fs.mkdir(dir, { recursive: true });\n      await fs.writeFile(resolvedPath, content, \"utf-8\");\n\n      return {\n        success: true,\n        output: `File written: ${resolvedPath}`,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n\nexport const editTool: ToolDefinition = {\n  name: \"edit\",\n  description: \"Edit content in a file by replacing text\",\n  parameters: [\n    {\n      name: \"filePath\",\n      type: \"string\",\n      description: \"The path to the file to edit\",\n      required: true,\n    },\n    {\n      name: \"oldString\",\n      type: \"string\",\n      description: \"The text to replace\",\n      required: true,\n    },\n    {\n      name: \"newString\",\n      type: \"string\",\n      description: \"The replacement text\",\n      required: true,\n    },\n    {\n      name: \"replaceAll\",\n      type: \"boolean\",\n      description: \"Replace all occurrences\",\n      required: false,\n      default: false,\n    },\n  ],\n\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    const filePath = args.filePath as string;\n    const oldString = args.oldString as string;\n    const newString = args.newString as string;\n    const replaceAll = (args.replaceAll as boolean) || false;\n\n    const resolvedPath = path.isAbsolute(filePath)\n      ? filePath\n      : path.resolve(context.workdir, filePath);\n\n    try {\n      const content = await fs.readFile(resolvedPath, \"utf-8\");\n\n      if (!content.includes(oldString)) {\n        return {\n          success: false,\n          error: \"oldString not found in content\",\n        };\n      }\n\n      const occurrences = content.split(oldString).length - 1;\n      if (occurrences > 1 && !replaceAll) {\n        return {\n          success: false,\n          error: `oldString found ${occurrences} times. Use replaceAll to replace all occurrences.`,\n        };\n      }\n\n      const newContent = replaceAll\n        ? content.split(oldString).join(newString)\n        : content.replace(oldString, newString);\n\n      await fs.writeFile(resolvedPath, newContent, \"utf-8\");\n\n      return {\n        success: true,\n        output: `File edited: ${resolvedPath}`,\n        data: { replacements: replaceAll ? occurrences : 1 },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n", "import type { ToolDefinition, ToolContext, ToolResult } from \"../types\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\n\nexport const grepTool: ToolDefinition = {\n  name: \"grep\",\n  description: \"Search for a pattern in files\",\n  parameters: [\n    {\n      name: \"pattern\",\n      type: \"string\",\n      description: \"The regex pattern to search for\",\n      required: true,\n    },\n    {\n      name: \"path\",\n      type: \"string\",\n      description: \"The directory or file to search in\",\n      required: false,\n    },\n    {\n      name: \"include\",\n      type: \"string\",\n      description: \"File pattern to include (e.g., '*.ts')\",\n      required: false,\n    },\n  ],\n\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    const pattern = args.pattern as string;\n    const searchPath = (args.path as string) || context.workdir;\n    const include = args.include as string | undefined;\n\n    const resolvedPath = path.isAbsolute(searchPath)\n      ? searchPath\n      : path.resolve(context.workdir, searchPath);\n\n    try {\n      const regex = new RegExp(pattern);\n      const matches: Array<{ file: string; line: number; content: string }> = [];\n\n      await searchDirectory(resolvedPath, regex, include, matches);\n\n      if (matches.length === 0) {\n        return {\n          success: true,\n          output: \"No matches found\",\n          data: { matches: [] },\n        };\n      }\n\n      const output = matches\n        .slice(0, 100)\n        .map((m) => `${m.file}:${m.line}: ${m.content.trim()}`)\n        .join(\"\\n\");\n\n      return {\n        success: true,\n        output,\n        data: { matches: matches.slice(0, 100), total: matches.length },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n\nasync function searchDirectory(\n  dir: string,\n  pattern: RegExp,\n  include: string | undefined,\n  matches: Array<{ file: string; line: number; content: string }>\n): Promise<void> {\n  const entries = await fs.readdir(dir, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const fullPath = path.join(dir, entry.name);\n\n    if (entry.name.startsWith(\".\") || entry.name === \"node_modules\") {\n      continue;\n    }\n\n    if (entry.isDirectory()) {\n      await searchDirectory(fullPath, pattern, include, matches);\n    } else if (entry.isFile()) {\n      if (include && !matchPattern(entry.name, include)) {\n        continue;\n      }\n\n      try {\n        const content = await fs.readFile(fullPath, \"utf-8\");\n        const lines = content.split(\"\\n\");\n\n        for (let i = 0; i < lines.length; i++) {\n          if (pattern.test(lines[i])) {\n            matches.push({\n              file: fullPath,\n              line: i + 1,\n              content: lines[i],\n            });\n          }\n        }\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  }\n}\n\nfunction matchPattern(filename: string, pattern: string): boolean {\n  const regex = new RegExp(\n    \"^\" + pattern.replace(/\\*/g, \".*\").replace(/\\?/g, \".\") + \"$\"\n  );\n  return regex.test(filename);\n}\n\nexport const globTool: ToolDefinition = {\n  name: \"glob\",\n  description: \"Find files matching a pattern\",\n  parameters: [\n    {\n      name: \"pattern\",\n      type: \"string\",\n      description: \"The glob pattern (e.g., '**/*.ts')\",\n      required: true,\n    },\n    {\n      name: \"path\",\n      type: \"string\",\n      description: \"The directory to search in\",\n      required: false,\n    },\n  ],\n\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    const pattern = args.pattern as string;\n    const searchPath = (args.path as string) || context.workdir;\n\n    const resolvedPath = path.isAbsolute(searchPath)\n      ? searchPath\n      : path.resolve(context.workdir, searchPath);\n\n    try {\n      const files: string[] = [];\n      await findFiles(resolvedPath, pattern, files);\n\n      if (files.length === 0) {\n        return {\n          success: true,\n          output: \"No files found\",\n          data: { files: [] },\n        };\n      }\n\n      return {\n        success: true,\n        output: `Found ${files.length} file(s)\\n\\n${files.slice(0, 100).join(\"\\n\")}`,\n        data: { files: files.slice(0, 100), total: files.length },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n\nasync function findFiles(\n  dir: string,\n  pattern: string,\n  files: string[]\n): Promise<void> {\n  const entries = await fs.readdir(dir, { withFileTypes: true });\n  const parts = pattern.split(\"/\");\n\n  for (const entry of entries) {\n    const fullPath = path.join(dir, entry.name);\n\n    if (entry.name.startsWith(\".\") || entry.name === \"node_modules\") {\n      continue;\n    }\n\n    if (entry.isDirectory()) {\n      if (parts[0] === \"**\") {\n        await findFiles(fullPath, pattern, files);\n      } else if (matchPattern(entry.name, parts[0])) {\n        await findFiles(fullPath, parts.slice(1).join(\"/\"), files);\n      }\n    } else if (entry.isFile()) {\n      const filePattern = parts[parts.length - 1];\n      if (matchPattern(entry.name, filePattern)) {\n        files.push(fullPath);\n      }\n    }\n  }\n}\n", "import type { ToolDefinition, ToolContext, ToolResult } from \"../types\";\nimport { getTodoManager } from \"../../services/agents/todo-manager\";\nimport type { Todo, TaskStatus } from \"../../services/agents/types\";\n\nexport const TodoWriteTool: ToolDefinition = {\n  name: \"todowrite\",\n  description: \"Use this tool to create or update your todo list. Provide an array of todo items with content, status, priority, and id. This allows the agent to track progress and work continuously until all tasks are completed.\",\n  parameters: [\n    {\n      name: \"todos\",\n      type: \"array\",\n      description: \"Array of todo items. Each item should have: content (brief description), status (pending|in_progress|completed|cancelled), priority (high|medium|low), id (unique identifier)\",\n      required: true,\n    },\n  ],\n  async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    try {\n      const todoManager = getTodoManager();\n      const todosArray = args.todos as Array<{ content: string; status: string; priority: string; id: string }>;\n\n      // Convert array format to Todo format\n      const todoItems: Todo[] = todosArray.map((item) => ({\n        id: item.id || crypto.randomUUID(),\n        sessionId: context.sessionId,\n        content: item.content,\n        status: item.status as TaskStatus,\n        priority: item.priority as \"high\" | \"medium\" | \"low\",\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      }));\n\n      // Use new setTodos method to replace entire list\n      todoManager.setTodos(context.sessionId, todoItems);\n\n      const pending = todoManager.listPending();\n\n      return {\n        success: true,\n        output: `Todo list updated with ${todosArray.length} items. ${pending.length} tasks remaining.`,\n        data: todoItems,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n\nexport const TodoReadTool: ToolDefinition = {\n  name: \"todoread\",\n  description: \"Use this tool to read your current todo list and see task progress. This helps track what tasks are pending, in progress, or completed.\",\n  parameters: [],\n  async execute(_args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {\n    try {\n      const todoManager = getTodoManager();\n      const todos = todoManager.list();\n      const pending = todoManager.listPending();\n\n      // Format todos for LLM\n      const formatted = todos\n        .map((todo) => {\n          const statusIcon = todo.status === \"completed\" ? \"\u2713\" : todo.status === \"in_progress\" ? \"\u2192\" : todo.status === \"failed\" ? \"\u2717\" : \"\u25CB\";\n          return `${statusIcon} [${todo.priority}] ${todo.content} (${todo.status})`;\n        })\n        .join(\"\\n\");\n\n      return {\n        success: true,\n        output: `Current todo list (${pending.length} pending, ${todos.length} total):\\n${formatted}`,\n        data: todos,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  },\n};\n", "export { bashTool } from \"./bash\";\nexport { readTool, writeTool, editTool } from \"./file\";\nexport { grepTool, globTool } from \"./search\";\nexport { TodoWriteTool, TodoReadTool } from \"./todo\";\n\nimport { getToolRegistry } from \"../tools\";\nimport { bashTool } from \"./bash\";\nimport { readTool, writeTool, editTool } from \"./file\";\nimport { grepTool, globTool } from \"./search\";\nimport { TodoWriteTool, TodoReadTool } from \"./todo\";\n\nexport function initializeTools(): void {\n  const registry = getToolRegistry();\n\n  registry.register(bashTool);\n  registry.register(readTool);\n  registry.register(writeTool);\n  registry.register(editTool);\n  registry.register(grepTool);\n  registry.register(globTool);\n  registry.register(TodoWriteTool);\n  registry.register(TodoReadTool);\n}\n", "/**\n * Claude (Anthropic) Auth Provider\n */\nimport * as clack from \"@clack/prompts\";\nimport { getTokenStore } from \"../../server/store/token-store\";\nimport type {\n  AuthProvider,\n  TokenData,\n  AuthResult,\n  LoginOptions,\n} from \"./types\";\nimport logger from \"../../shared/logger\";\n\nexport class ClaudeAuthProvider implements AuthProvider {\n  readonly name = \"claude\" as const;\n  readonly displayName = \"Claude (Anthropic)\";\n\n  private tokenStore = getTokenStore();\n\n  async login(options?: LoginOptions): Promise<AuthResult> {\n    try {\n      // Priority: options.apiKey > env > interactive prompt\n      let apiKey = options?.apiKey || process.env.ANTHROPIC_API_KEY;\n\n      if (!apiKey && options?.interactive !== false) {\n        clack.note(\n          \"Get your API key from:\\n\" +\n          \"https://console.anthropic.com/settings/keys\"\n        );\n\n        const input = await clack.password({\n          message: \"Enter your Anthropic API key:\",\n          validate: (value) => {\n            if (!value) return \"API key is required\";\n            if (!value.startsWith(\"sk-ant-\")) {\n              return \"Invalid API key format (should start with sk-ant-)\";\n            }\n          },\n        });\n\n        if (clack.isCancel(input)) {\n          return { success: false, error: \"Login cancelled\" };\n        }\n\n        apiKey = input as string;\n      }\n\n      if (!apiKey) {\n        return { success: false, error: \"API key is required\" };\n      }\n\n      // Validate API key\n      const isValid = await this.validateApiKey(apiKey);\n      if (!isValid) {\n        return { success: false, error: \"Invalid API key\" };\n      }\n\n      // Store token\n      const tokenData: TokenData = {\n        accessToken: apiKey,\n        provider: this.name,\n        type: \"api_key\",\n        expiresAt: Number.MAX_SAFE_INTEGER, // API keys don't expire\n      };\n\n      await this.tokenStore.store(this.name, tokenData);\n\n      return { success: true, provider: this.name };\n    } catch (error) {\n      logger.error(\"Claude login failed\", error as Error);\n      return { success: false, error: (error as Error).message };\n    }\n  }\n\n  async logout(accountId?: string): Promise<void> {\n    await this.tokenStore.delete(this.name, accountId);\n  }\n\n  async getToken(accountId?: string): Promise<string | null> {\n    const tokens = await this.tokenStore.retrieve(this.name, accountId);\n    return tokens?.accessToken ?? null;\n  }\n\n  async isAuthenticated(accountId?: string): Promise<boolean> {\n    return this.tokenStore.isValid(this.name, accountId);\n  }\n\n  private async validateApiKey(apiKey: string): Promise<boolean> {\n    try {\n      const response = await fetch(\"https://api.anthropic.com/v1/messages\", {\n        method: \"POST\",\n        headers: {\n          \"x-api-key\": apiKey,\n          \"anthropic-version\": \"2023-06-01\",\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          model: \"claude-3-haiku-20240307\",\n          max_tokens: 1,\n          messages: [{ role: \"user\", content: \"test\" }],\n        }),\n      });\n\n      // 200 or 400 (bad request) means key is valid\n      // 401 means invalid key\n      return response.status !== 401;\n    } catch (error) {\n      logger.error(\"API key validation failed\", error as Error);\n      return false;\n    }\n  }\n}\n", "/**\n * Token Store\n * Secure storage for API keys and OAuth tokens\n */\nimport { promises as fs } from \"fs\";\nimport { existsSync, mkdirSync } from \"fs\";\nimport * as crypto from \"crypto\";\nimport path from \"path\";\nimport type { TokenData, AuthProviderName } from \"../../services/auth/types\";\nimport logger from \"../../shared/logger\";\n\ninterface EncryptedData {\n  encryptedData: string;\n  iv: string;\n  authTag: string;\n}\n\nexport class TokenStore {\n  private readonly ALGORITHM = \"aes-256-gcm\";\n  private readonly KEY_LENGTH = 32;\n  private readonly IV_LENGTH = 16;\n  private encryptionKey: Buffer | null = null;\n\n  private readonly configDir: string;\n  private readonly keyFile: string;\n\n  constructor() {\n    const home = process.env.HOME || process.env.USERPROFILE || \".\";\n    this.configDir = path.join(home, \".config\", \"supercoin\");\n    this.keyFile = path.join(this.configDir, \".key\");\n\n    // Ensure config directory exists\n    if (!existsSync(this.configDir)) {\n      mkdirSync(this.configDir, { recursive: true, mode: 0o700 });\n    }\n  }\n\n  /**\n   * Get or create encryption key\n   */\n  private async getEncryptionKey(): Promise<Buffer> {\n    if (this.encryptionKey) {\n      return this.encryptionKey;\n    }\n\n    // Try to read existing key\n    if (existsSync(this.keyFile)) {\n      try {\n        const keyHex = await fs.readFile(this.keyFile, \"utf-8\");\n        this.encryptionKey = Buffer.from(keyHex.trim(), \"hex\");\n        return this.encryptionKey;\n      } catch {\n        // Key file corrupted, generate new\n      }\n    }\n\n    // Generate new key\n    this.encryptionKey = crypto.randomBytes(this.KEY_LENGTH);\n    await fs.writeFile(this.keyFile, this.encryptionKey.toString(\"hex\"), {\n      mode: 0o600,\n    });\n\n    return this.encryptionKey;\n  }\n\n  /**\n   * Encrypt data\n   */\n  private async encrypt(data: string): Promise<EncryptedData> {\n    const key = await this.getEncryptionKey();\n    const iv = crypto.randomBytes(this.IV_LENGTH);\n    const cipher = crypto.createCipheriv(this.ALGORITHM, key, iv);\n\n    let encrypted = cipher.update(data, \"utf8\", \"base64\");\n    encrypted += cipher.final(\"base64\");\n    const authTag = cipher.getAuthTag();\n\n    return {\n      encryptedData: encrypted,\n      iv: iv.toString(\"base64\"),\n      authTag: authTag.toString(\"base64\"),\n    };\n  }\n\n  /**\n   * Decrypt data\n   */\n  private async decrypt(encrypted: EncryptedData): Promise<string> {\n    const key = await this.getEncryptionKey();\n    const iv = Buffer.from(encrypted.iv, \"base64\");\n    const authTag = Buffer.from(encrypted.authTag, \"base64\");\n    const decipher = crypto.createDecipheriv(this.ALGORITHM, key, iv);\n    decipher.setAuthTag(authTag);\n\n    let decrypted = decipher.update(encrypted.encryptedData, \"base64\", \"utf8\");\n    decrypted += decipher.final(\"utf8\");\n    return decrypted;\n  }\n\n  /**\n   * Get token file path\n   */\n  private getTokenFilePath(provider: AuthProviderName, accountId?: string): string {\n    const fileName = accountId ? `${provider}_${accountId}.token` : `${provider}.token`;\n    return path.join(this.configDir, fileName);\n  }\n\n  /**\n   * Get all token files for a provider\n   */\n  private async getAllTokenFiles(provider: AuthProviderName): Promise<string[]> {\n    const files: string[] = [];\n    const { promises: fsp } = await import(\"fs\");\n    \n    try {\n      const dirFiles = await fsp.readdir(this.configDir);\n      for (const file of dirFiles) {\n        if (file.startsWith(`${provider}_`) && file.endsWith(\".token\")) {\n          files.push(path.join(this.configDir, file));\n        } else if (file === `${provider}.token`) {\n          files.push(path.join(this.configDir, file));\n        }\n      }\n    } catch {\n      // Directory might not exist yet\n    }\n    \n    return files;\n  }\n\n  /**\n   * Store token\n   */\n  async store(provider: AuthProviderName, tokens: TokenData): Promise<void> {\n    const filePath = this.getTokenFilePath(provider, tokens.accountId);\n    const encrypted = await this.encrypt(JSON.stringify(tokens));\n\n    await fs.writeFile(filePath, JSON.stringify(encrypted), {\n      mode: 0o600,\n    });\n\n    logger.debug(`Token stored for ${provider}${tokens.accountId ? ` (${tokens.accountId})` : \"\"}`);\n  }\n\n  /**\n   * Retrieve token\n   */\n  async retrieve(provider: AuthProviderName, accountId?: string): Promise<TokenData | null> {\n    const filePath = this.getTokenFilePath(provider, accountId);\n\n    try {\n      if (!existsSync(filePath)) {\n        return null;\n      }\n\n      const content = await fs.readFile(filePath, \"utf-8\");\n      const encrypted: EncryptedData = JSON.parse(content);\n      const decrypted = await this.decrypt(encrypted);\n\n      return JSON.parse(decrypted) as TokenData;\n    } catch (error) {\n      logger.error(`Failed to retrieve token for ${provider}${accountId ? ` (${accountId})` : \"\"}`, error as Error);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieve all tokens for a provider\n   */\n  async retrieveAll(provider: AuthProviderName): Promise<TokenData[]> {\n    const files = await this.getAllTokenFiles(provider);\n    const tokens: TokenData[] = [];\n\n    for (const filePath of files) {\n      try {\n        const content = await fs.readFile(filePath, \"utf-8\");\n        const encrypted: EncryptedData = JSON.parse(content);\n        const decrypted = await this.decrypt(encrypted);\n        tokens.push(JSON.parse(decrypted) as TokenData);\n      } catch (error) {\n        logger.error(`Failed to retrieve token from ${filePath}`, error as Error);\n      }\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Delete token\n   */\n  async delete(provider: AuthProviderName, accountId?: string): Promise<void> {\n    if (accountId === \"*\") {\n      const files = await this.getAllTokenFiles(provider);\n      for (const filePath of files) {\n        try {\n          await fs.unlink(filePath);\n        } catch (error) {\n          logger.error(`Failed to delete token file ${filePath}`, error as Error);\n        }\n      }\n      logger.debug(`All tokens deleted for ${provider}`);\n      return;\n    }\n\n    const filePath = this.getTokenFilePath(provider, accountId);\n\n    try {\n      if (existsSync(filePath)) {\n        await fs.unlink(filePath);\n        logger.debug(`Token deleted for ${provider}${accountId ? ` (${accountId})` : \"\"}`);\n      }\n    } catch (error) {\n      logger.error(`Failed to delete token for ${provider}${accountId ? ` (${accountId})` : \"\"}`, error as Error);\n    }\n  }\n\n  /**\n   * Check if token is valid (not expired)\n   */\n  async isValid(provider: AuthProviderName, accountId?: string): Promise<boolean> {\n    const tokens = await this.retrieve(provider, accountId);\n    if (!tokens) return false;\n\n    if (tokens.type === \"api_key\") return true;\n\n    const bufferMs = 5 * 60 * 1000;\n    return tokens.expiresAt > Date.now() + bufferMs;\n  }\n\n  /**\n   * Check if token needs refresh\n   */\n  async needsRefresh(provider: AuthProviderName, accountId?: string): Promise<boolean> {\n    const tokens = await this.retrieve(provider, accountId);\n    if (!tokens) return false;\n\n    if (tokens.type === \"api_key\") return false;\n\n    const refreshWindowMs = 15 * 60 * 1000;\n    return tokens.expiresAt < Date.now() + refreshWindowMs;\n  }\n}\n\n// Singleton instance\nlet tokenStoreInstance: TokenStore | null = null;\n\nexport function getTokenStore(): TokenStore {\n  if (!tokenStoreInstance) {\n    tokenStoreInstance = new TokenStore();\n  }\n  return tokenStoreInstance;\n}\n", "/**\n * Codex (OpenAI) Auth Provider\n */\nimport * as clack from \"@clack/prompts\";\nimport { getTokenStore } from \"../../server/store/token-store\";\nimport type {\n  AuthProvider,\n  TokenData,\n  AuthResult,\n  LoginOptions,\n} from \"./types\";\nimport logger from \"../../shared/logger\";\n\nexport class CodexAuthProvider implements AuthProvider {\n  readonly name = \"codex\" as const;\n  readonly displayName = \"Codex (OpenAI)\";\n\n  private tokenStore = getTokenStore();\n\n  async login(options?: LoginOptions): Promise<AuthResult> {\n    try {\n      // Priority: options.apiKey > env > interactive prompt\n      let apiKey = options?.apiKey || process.env.OPENAI_API_KEY;\n\n      if (!apiKey && options?.interactive !== false) {\n        clack.note(\n          \"Get your API key from:\\n\" +\n          \"https://platform.openai.com/api-keys\"\n        );\n\n        const input = await clack.password({\n          message: \"Enter your OpenAI API key:\",\n          validate: (value) => {\n            if (!value) return \"API key is required\";\n            if (!value.startsWith(\"sk-\")) {\n              return \"Invalid API key format (should start with sk-)\";\n            }\n          },\n        });\n\n        if (clack.isCancel(input)) {\n          return { success: false, error: \"Login cancelled\" };\n        }\n\n        apiKey = input as string;\n      }\n\n      if (!apiKey) {\n        return { success: false, error: \"API key is required\" };\n      }\n\n      // Validate API key\n      const isValid = await this.validateApiKey(apiKey);\n      if (!isValid) {\n        return { success: false, error: \"Invalid API key\" };\n      }\n\n      // Store token\n      const tokenData: TokenData = {\n        accessToken: apiKey,\n        provider: this.name,\n        type: \"api_key\",\n        expiresAt: Number.MAX_SAFE_INTEGER,\n      };\n\n      await this.tokenStore.store(this.name, tokenData);\n\n      return { success: true, provider: this.name };\n    } catch (error) {\n      logger.error(\"Codex login failed\", error as Error);\n      return { success: false, error: (error as Error).message };\n    }\n  }\n\n  async logout(accountId?: string): Promise<void> {\n    await this.tokenStore.delete(this.name, accountId);\n  }\n\n  async getToken(accountId?: string): Promise<string | null> {\n    const tokens = await this.tokenStore.retrieve(this.name, accountId);\n    return tokens?.accessToken ?? null;\n  }\n\n  async isAuthenticated(accountId?: string): Promise<boolean> {\n    return this.tokenStore.isValid(this.name, accountId);\n  }\n\n  private async validateApiKey(apiKey: string): Promise<boolean> {\n    try {\n      const response = await fetch(\"https://api.openai.com/v1/models\", {\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n        },\n      });\n\n      return response.status === 200;\n    } catch (error) {\n      logger.error(\"API key validation failed\", error as Error);\n      return false;\n    }\n  }\n}\n", "/**\n * Gemini (Google) Auth Provider\n * Supports both API Key and OAuth with PKCE (via Antigravity)\n */\nimport * as clack from \"@clack/prompts\";\nimport { exec } from \"child_process\";\nimport { getTokenStore } from \"../../server/store/token-store\";\nimport { getOAuthStateStore } from \"../../server/store/oauth-state-store\";\nimport { startServer, isServerRunning } from \"../../server/index\";\nimport { waitForCallback } from \"../../server/routes/auth-callback\";\nimport type {\n  AuthProvider,\n  TokenData,\n  AuthResult,\n  LoginOptions,\n  OAuthState,\n} from \"./types\";\nimport logger from \"../../shared/logger\";\n\nconst ANTIGRAVITY_CLIENT_ID = \"1071006060591-tmhssin2h21lcre235vtolojh4g403ep.apps.googleusercontent.com\";\nconst ANTIGRAVITY_CLIENT_SECRET = \"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\";\nconst ANTIGRAVITY_SCOPES = [\n  \"https://www.googleapis.com/auth/cloud-platform\",\n  \"https://www.googleapis.com/auth/userinfo.email\",\n  \"https://www.googleapis.com/auth/userinfo.profile\",\n  \"https://www.googleapis.com/auth/cclog\",\n  \"https://www.googleapis.com/auth/experimentsandconfigs\",\n  \"https://www.googleapis.com/auth/generative-language.retriever\",\n];\nconst GOOGLE_AUTH_URL = \"https://accounts.google.com/o/oauth2/v2/auth\";\nconst GOOGLE_TOKEN_URL = \"https://oauth2.googleapis.com/token\";\nconst DEFAULT_SERVER_PORT = 3100;\n\nexport class GeminiAuthProvider implements AuthProvider {\n  readonly name = \"gemini\" as const;\n  readonly displayName = \"Gemini (Google)\";\n\n  private tokenStore = getTokenStore();\n  private oauthStateStore = getOAuthStateStore();\n\n  async login(options?: LoginOptions): Promise<AuthResult> {\n    try {\n      let apiKey = options?.apiKey || process.env.GOOGLE_API_KEY;\n\n      if (apiKey) {\n        return await this.loginWithApiKey(apiKey, options?.accountId);\n      }\n\n      if (options?.interactive !== false) {\n        const authMethod = await clack.select({\n          message: \"Select Gemini authentication method:\",\n          options: [\n            { value: \"oauth\", label: \"OAuth with Antigravity (Recommended)\", hint: \"Browser login\" },\n            { value: \"apikey\", label: \"API Key\", hint: \"Direct key input\" },\n          ],\n        });\n\n        if (clack.isCancel(authMethod)) {\n          return { success: false, error: \"Login cancelled\" };\n        }\n\n        if (authMethod === \"apikey\") {\n          const input = await clack.password({\n            message: \"Enter your Google AI API key:\",\n            validate: (value) => {\n              if (!value) return \"API key is required\";\n            },\n          });\n\n          if (clack.isCancel(input)) {\n            return { success: false, error: \"Login cancelled\" };\n          }\n          return await this.loginWithApiKey(input as string, options?.accountId);\n        } else {\n          return await this.loginWithOAuth(options?.accountId);\n        }\n      }\n\n      return { success: false, error: \"Authentication required\" };\n    } catch (error) {\n      logger.error(\"Gemini login failed\", error as Error);\n      return { success: false, error: (error as Error).message };\n    }\n  }\n\n  private async loginWithApiKey(apiKey: string, accountId?: string): Promise<AuthResult> {\n    const isValid = await this.validateApiKey(apiKey);\n    if (!isValid) {\n      return { success: false, error: \"Invalid API key\" };\n    }\n\n    const tokenData: TokenData = {\n      accessToken: apiKey,\n      provider: this.name,\n      type: \"api_key\",\n      expiresAt: Number.MAX_SAFE_INTEGER,\n      accountId: accountId || \"default\",\n    };\n\n    await this.tokenStore.store(this.name, tokenData);\n    return { success: true, provider: this.name, accountId: tokenData.accountId };\n  }\n\n  private async loginWithOAuth(accountId?: string): Promise<AuthResult> {\n    try {\n      if (!isServerRunning()) {\n        await startServer({ port: DEFAULT_SERVER_PORT, host: \"127.0.0.1\" });\n      }\n\n      const redirectUri = `http://localhost:${DEFAULT_SERVER_PORT}/callback/${this.name}`;\n      \n      const { verifier, challenge } = this.oauthStateStore.generatePKCEPair();\n      const state = this.oauthStateStore.generateState();\n\n      const oauthState: OAuthState = {\n        provider: this.name,\n        state,\n        codeVerifier: verifier,\n        createdAt: Date.now(),\n        accountId: accountId || `account_${Date.now()}`,\n      };\n\n      await this.oauthStateStore.store(oauthState);\n\n      const params = new URLSearchParams({\n        client_id: ANTIGRAVITY_CLIENT_ID,\n        response_type: \"code\",\n        redirect_uri: redirectUri,\n        scope: ANTIGRAVITY_SCOPES.join(\" \"),\n        code_challenge: challenge,\n        code_challenge_method: \"S256\",\n        state,\n        access_type: \"offline\",\n        prompt: \"consent\",\n      });\n\n      const authUrl = `${GOOGLE_AUTH_URL}?${params}`;\n\n      clack.note(`Opening browser for authentication...\\nIf browser doesn't open, visit:\\n${authUrl}`);\n      this.openBrowser(authUrl);\n\n      const { code, state: returnedState } = await waitForCallback(this.name, 120000);\n\n      const storedState = await this.oauthStateStore.retrieve(returnedState);\n      if (!storedState || storedState.state !== returnedState) {\n        throw new Error(\"Invalid state parameter (CSRF protection)\");\n      }\n\n      await this.exchangeCode(code, storedState.codeVerifier!, redirectUri, storedState.accountId!);\n      await this.oauthStateStore.delete(returnedState);\n\n      return { success: true, provider: this.name, accountId: storedState.accountId };\n    } catch (error) {\n      logger.error(\"OAuth flow failed\", error as Error);\n      return { success: false, error: (error as Error).message };\n    }\n  }\n\n  async logout(accountId?: string): Promise<void> {\n    const tokens = await this.tokenStore.retrieve(this.name, accountId);\n    if (tokens?.type === \"oauth\" && tokens.accessToken) {\n      try {\n        await fetch(`https://oauth2.googleapis.com/revoke?token=${tokens.accessToken}`, {\n          method: \"POST\",\n        });\n      } catch {\n        // Ignore revocation errors\n      }\n    }\n    await this.tokenStore.delete(this.name, accountId);\n  }\n\n  async refresh(accountId?: string): Promise<TokenData> {\n    const currentTokens = await this.tokenStore.retrieve(this.name, accountId);\n    if (!currentTokens?.refreshToken) {\n      throw new Error(\"No refresh token available\");\n    }\n\n    const response = await fetch(GOOGLE_TOKEN_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n      body: new URLSearchParams({\n        client_id: ANTIGRAVITY_CLIENT_ID,\n        client_secret: ANTIGRAVITY_CLIENT_SECRET,\n        refresh_token: currentTokens.refreshToken,\n        grant_type: \"refresh_token\",\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Token refresh failed\");\n    }\n\n    const data = await response.json() as { access_token: string; expires_in: number; refresh_token?: string };\n    \n    const newTokenData: TokenData = {\n      ...currentTokens,\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token || currentTokens.refreshToken,\n      expiresAt: Date.now() + data.expires_in * 1000,\n    };\n\n    await this.tokenStore.store(this.name, newTokenData);\n    return newTokenData;\n  }\n\n  async getToken(accountId?: string): Promise<string | null> {\n    const tokens = await this.tokenStore.retrieve(this.name, accountId);\n    if (!tokens) return null;\n\n    if (tokens.type === \"oauth\") {\n      const needsRefresh = await this.tokenStore.needsRefresh(this.name, accountId);\n      if (needsRefresh && tokens.refreshToken) {\n        try {\n          const newTokens = await this.refresh(accountId);\n          return newTokens.accessToken;\n        } catch {\n          return null;\n        }\n      }\n    }\n    return tokens.accessToken;\n  }\n\n  async isAuthenticated(accountId?: string): Promise<boolean> {\n    return this.tokenStore.isValid(this.name, accountId);\n  }\n\n  private async validateApiKey(apiKey: string): Promise<boolean> {\n    try {\n      const response = await fetch(\n        `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`\n      );\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n\n  private async exchangeCode(code: string, verifier: string, redirectUri: string, accountId: string): Promise<TokenData> {\n    const response = await fetch(GOOGLE_TOKEN_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n      body: new URLSearchParams({\n        client_id: ANTIGRAVITY_CLIENT_ID,\n        client_secret: ANTIGRAVITY_CLIENT_SECRET,\n        code,\n        code_verifier: verifier,\n        grant_type: \"authorization_code\",\n        redirect_uri: redirectUri,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Token exchange failed: ${await response.text()}`);\n    }\n\n    const data = await response.json() as { \n      access_token: string; \n      refresh_token?: string; \n      expires_in: number \n    };\n\n    const tokenData: TokenData = {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      provider: this.name,\n      type: \"oauth\",\n      expiresAt: Date.now() + data.expires_in * 1000,\n      scopes: ANTIGRAVITY_SCOPES,\n      accountId,\n    };\n\n    await this.tokenStore.store(this.name, tokenData);\n    return tokenData;\n  }\n\n  private openBrowser(url: string) {\n    const start = process.platform === \"darwin\" ? \"open\" : process.platform === \"win32\" ? \"start\" : \"xdg-open\";\n    exec(`${start} \"${url}\"`);\n  }\n}\n", "import { promises as fs } from \"fs\";\nimport { existsSync } from \"fs\";\nimport * as crypto from \"crypto\";\nimport path from \"path\";\nimport type { OAuthState, AuthProviderName } from \"../../services/auth/types\";\nimport logger from \"../../shared/logger\";\n\nconst STATE_EXPIRY_MS = 10 * 60 * 1000;\n\nexport class OAuthStateStore {\n  private states: Map<string, OAuthState> = new Map();\n  private readonly configDir: string;\n  private readonly stateFile: string;\n\n  constructor() {\n    const home = process.env.HOME || process.env.USERPROFILE || \".\";\n    this.configDir = path.join(home, \".config\", \"supercoin\");\n    this.stateFile = path.join(this.configDir, \".oauth-states\");\n    this.loadStates();\n    this.startCleanupTimer();\n  }\n\n  private async loadStates(): Promise<void> {\n    try {\n      if (existsSync(this.stateFile)) {\n        const content = await fs.readFile(this.stateFile, \"utf-8\");\n        const data = JSON.parse(content);\n        this.states = new Map(Object.entries(data));\n        this.cleanupExpired();\n      }\n    } catch (error) {\n      logger.error(\"Failed to load OAuth states\", error as Error);\n      this.states.clear();\n    }\n  }\n\n  private async saveStates(): Promise<void> {\n    try {\n      const data = Object.fromEntries(this.states);\n      await fs.writeFile(this.stateFile, JSON.stringify(data), { mode: 0o600 });\n    } catch (error) {\n      logger.error(\"Failed to save OAuth states\", error as Error);\n    }\n  }\n\n  async store(state: OAuthState): Promise<void> {\n    this.states.set(state.state, state);\n    await this.saveStates();\n  }\n\n  async retrieve(stateValue: string): Promise<OAuthState | null> {\n    const state = this.states.get(stateValue);\n    if (!state) return null;\n\n    if (Date.now() - state.createdAt > STATE_EXPIRY_MS) {\n      this.states.delete(stateValue);\n      await this.saveStates();\n      return null;\n    }\n\n    return state;\n  }\n\n  async delete(stateValue: string): Promise<void> {\n    this.states.delete(stateValue);\n    await this.saveStates();\n  }\n\n  async deleteByProvider(provider: AuthProviderName): Promise<void> {\n    for (const [key, value] of this.states.entries()) {\n      if (value.provider === provider) {\n        this.states.delete(key);\n      }\n    }\n    await this.saveStates();\n  }\n\n  private cleanupExpired(): void {\n    const now = Date.now();\n    for (const [key, value] of this.states.entries()) {\n      if (now - value.createdAt > STATE_EXPIRY_MS) {\n        this.states.delete(key);\n      }\n    }\n  }\n\n  private startCleanupTimer(): void {\n    setInterval(() => {\n      this.cleanupExpired();\n      this.saveStates();\n    }, 60000);\n  }\n\n  generatePKCEPair(): { verifier: string; challenge: string } {\n    const verifier = crypto.randomBytes(64).toString(\"base64url\");\n    const challenge = crypto.createHash(\"sha256\").update(verifier).digest(\"base64url\");\n    return { verifier, challenge };\n  }\n\n  generateState(): string {\n    return crypto.randomBytes(32).toString(\"hex\");\n  }\n}\n\nlet oauthStateStoreInstance: OAuthStateStore | null = null;\n\nexport function getOAuthStateStore(): OAuthStateStore {\n  if (!oauthStateStoreInstance) {\n    oauthStateStoreInstance = new OAuthStateStore();\n  }\n  return oauthStateStoreInstance;\n}\n", "// src/server.ts\nimport { createServer as createServerHTTP } from \"http\";\n\n// src/listener.ts\nimport { Http2ServerRequest as Http2ServerRequest2 } from \"http2\";\n\n// src/request.ts\nimport { Http2ServerRequest } from \"http2\";\nimport { Readable } from \"stream\";\nvar RequestError = class extends Error {\n  constructor(message, options) {\n    super(message, options);\n    this.name = \"RequestError\";\n  }\n};\nvar toRequestError = (e) => {\n  if (e instanceof RequestError) {\n    return e;\n  }\n  return new RequestError(e.message, { cause: e });\n};\nvar GlobalRequest = global.Request;\nvar Request = class extends GlobalRequest {\n  constructor(input, options) {\n    if (typeof input === \"object\" && getRequestCache in input) {\n      input = input[getRequestCache]();\n    }\n    if (typeof options?.body?.getReader !== \"undefined\") {\n      ;\n      options.duplex ??= \"half\";\n    }\n    super(input, options);\n  }\n};\nvar newHeadersFromIncoming = (incoming) => {\n  const headerRecord = [];\n  const rawHeaders = incoming.rawHeaders;\n  for (let i = 0; i < rawHeaders.length; i += 2) {\n    const { [i]: key, [i + 1]: value } = rawHeaders;\n    if (key.charCodeAt(0) !== /*:*/\n    58) {\n      headerRecord.push([key, value]);\n    }\n  }\n  return new Headers(headerRecord);\n};\nvar wrapBodyStream = Symbol(\"wrapBodyStream\");\nvar newRequestFromIncoming = (method, url, headers, incoming, abortController) => {\n  const init = {\n    method,\n    headers,\n    signal: abortController.signal\n  };\n  if (method === \"TRACE\") {\n    init.method = \"GET\";\n    const req = new Request(url, init);\n    Object.defineProperty(req, \"method\", {\n      get() {\n        return \"TRACE\";\n      }\n    });\n    return req;\n  }\n  if (!(method === \"GET\" || method === \"HEAD\")) {\n    if (\"rawBody\" in incoming && incoming.rawBody instanceof Buffer) {\n      init.body = new ReadableStream({\n        start(controller) {\n          controller.enqueue(incoming.rawBody);\n          controller.close();\n        }\n      });\n    } else if (incoming[wrapBodyStream]) {\n      let reader;\n      init.body = new ReadableStream({\n        async pull(controller) {\n          try {\n            reader ||= Readable.toWeb(incoming).getReader();\n            const { done, value } = await reader.read();\n            if (done) {\n              controller.close();\n            } else {\n              controller.enqueue(value);\n            }\n          } catch (error) {\n            controller.error(error);\n          }\n        }\n      });\n    } else {\n      init.body = Readable.toWeb(incoming);\n    }\n  }\n  return new Request(url, init);\n};\nvar getRequestCache = Symbol(\"getRequestCache\");\nvar requestCache = Symbol(\"requestCache\");\nvar incomingKey = Symbol(\"incomingKey\");\nvar urlKey = Symbol(\"urlKey\");\nvar headersKey = Symbol(\"headersKey\");\nvar abortControllerKey = Symbol(\"abortControllerKey\");\nvar getAbortController = Symbol(\"getAbortController\");\nvar requestPrototype = {\n  get method() {\n    return this[incomingKey].method || \"GET\";\n  },\n  get url() {\n    return this[urlKey];\n  },\n  get headers() {\n    return this[headersKey] ||= newHeadersFromIncoming(this[incomingKey]);\n  },\n  [getAbortController]() {\n    this[getRequestCache]();\n    return this[abortControllerKey];\n  },\n  [getRequestCache]() {\n    this[abortControllerKey] ||= new AbortController();\n    return this[requestCache] ||= newRequestFromIncoming(\n      this.method,\n      this[urlKey],\n      this.headers,\n      this[incomingKey],\n      this[abortControllerKey]\n    );\n  }\n};\n[\n  \"body\",\n  \"bodyUsed\",\n  \"cache\",\n  \"credentials\",\n  \"destination\",\n  \"integrity\",\n  \"mode\",\n  \"redirect\",\n  \"referrer\",\n  \"referrerPolicy\",\n  \"signal\",\n  \"keepalive\"\n].forEach((k) => {\n  Object.defineProperty(requestPrototype, k, {\n    get() {\n      return this[getRequestCache]()[k];\n    }\n  });\n});\n[\"arrayBuffer\", \"blob\", \"clone\", \"formData\", \"json\", \"text\"].forEach((k) => {\n  Object.defineProperty(requestPrototype, k, {\n    value: function() {\n      return this[getRequestCache]()[k]();\n    }\n  });\n});\nObject.setPrototypeOf(requestPrototype, Request.prototype);\nvar newRequest = (incoming, defaultHostname) => {\n  const req = Object.create(requestPrototype);\n  req[incomingKey] = incoming;\n  const incomingUrl = incoming.url || \"\";\n  if (incomingUrl[0] !== \"/\" && // short-circuit for performance. most requests are relative URL.\n  (incomingUrl.startsWith(\"http://\") || incomingUrl.startsWith(\"https://\"))) {\n    if (incoming instanceof Http2ServerRequest) {\n      throw new RequestError(\"Absolute URL for :path is not allowed in HTTP/2\");\n    }\n    try {\n      const url2 = new URL(incomingUrl);\n      req[urlKey] = url2.href;\n    } catch (e) {\n      throw new RequestError(\"Invalid absolute URL\", { cause: e });\n    }\n    return req;\n  }\n  const host = (incoming instanceof Http2ServerRequest ? incoming.authority : incoming.headers.host) || defaultHostname;\n  if (!host) {\n    throw new RequestError(\"Missing host header\");\n  }\n  let scheme;\n  if (incoming instanceof Http2ServerRequest) {\n    scheme = incoming.scheme;\n    if (!(scheme === \"http\" || scheme === \"https\")) {\n      throw new RequestError(\"Unsupported scheme\");\n    }\n  } else {\n    scheme = incoming.socket && incoming.socket.encrypted ? \"https\" : \"http\";\n  }\n  const url = new URL(`${scheme}://${host}${incomingUrl}`);\n  if (url.hostname.length !== host.length && url.hostname !== host.replace(/:\\d+$/, \"\")) {\n    throw new RequestError(\"Invalid host header\");\n  }\n  req[urlKey] = url.href;\n  return req;\n};\n\n// src/response.ts\nvar responseCache = Symbol(\"responseCache\");\nvar getResponseCache = Symbol(\"getResponseCache\");\nvar cacheKey = Symbol(\"cache\");\nvar GlobalResponse = global.Response;\nvar Response2 = class _Response {\n  #body;\n  #init;\n  [getResponseCache]() {\n    delete this[cacheKey];\n    return this[responseCache] ||= new GlobalResponse(this.#body, this.#init);\n  }\n  constructor(body, init) {\n    let headers;\n    this.#body = body;\n    if (init instanceof _Response) {\n      const cachedGlobalResponse = init[responseCache];\n      if (cachedGlobalResponse) {\n        this.#init = cachedGlobalResponse;\n        this[getResponseCache]();\n        return;\n      } else {\n        this.#init = init.#init;\n        headers = new Headers(init.#init.headers);\n      }\n    } else {\n      this.#init = init;\n    }\n    if (typeof body === \"string\" || typeof body?.getReader !== \"undefined\" || body instanceof Blob || body instanceof Uint8Array) {\n      headers ||= init?.headers || { \"content-type\": \"text/plain; charset=UTF-8\" };\n      this[cacheKey] = [init?.status || 200, body, headers];\n    }\n  }\n  get headers() {\n    const cache = this[cacheKey];\n    if (cache) {\n      if (!(cache[2] instanceof Headers)) {\n        cache[2] = new Headers(cache[2]);\n      }\n      return cache[2];\n    }\n    return this[getResponseCache]().headers;\n  }\n  get status() {\n    return this[cacheKey]?.[0] ?? this[getResponseCache]().status;\n  }\n  get ok() {\n    const status = this.status;\n    return status >= 200 && status < 300;\n  }\n};\n[\"body\", \"bodyUsed\", \"redirected\", \"statusText\", \"trailers\", \"type\", \"url\"].forEach((k) => {\n  Object.defineProperty(Response2.prototype, k, {\n    get() {\n      return this[getResponseCache]()[k];\n    }\n  });\n});\n[\"arrayBuffer\", \"blob\", \"clone\", \"formData\", \"json\", \"text\"].forEach((k) => {\n  Object.defineProperty(Response2.prototype, k, {\n    value: function() {\n      return this[getResponseCache]()[k]();\n    }\n  });\n});\nObject.setPrototypeOf(Response2, GlobalResponse);\nObject.setPrototypeOf(Response2.prototype, GlobalResponse.prototype);\n\n// src/utils.ts\nasync function readWithoutBlocking(readPromise) {\n  return Promise.race([readPromise, Promise.resolve().then(() => Promise.resolve(void 0))]);\n}\nfunction writeFromReadableStreamDefaultReader(reader, writable, currentReadPromise) {\n  const cancel = (error) => {\n    reader.cancel(error).catch(() => {\n    });\n  };\n  writable.on(\"close\", cancel);\n  writable.on(\"error\", cancel);\n  (currentReadPromise ?? reader.read()).then(flow, handleStreamError);\n  return reader.closed.finally(() => {\n    writable.off(\"close\", cancel);\n    writable.off(\"error\", cancel);\n  });\n  function handleStreamError(error) {\n    if (error) {\n      writable.destroy(error);\n    }\n  }\n  function onDrain() {\n    reader.read().then(flow, handleStreamError);\n  }\n  function flow({ done, value }) {\n    try {\n      if (done) {\n        writable.end();\n      } else if (!writable.write(value)) {\n        writable.once(\"drain\", onDrain);\n      } else {\n        return reader.read().then(flow, handleStreamError);\n      }\n    } catch (e) {\n      handleStreamError(e);\n    }\n  }\n}\nfunction writeFromReadableStream(stream, writable) {\n  if (stream.locked) {\n    throw new TypeError(\"ReadableStream is locked.\");\n  } else if (writable.destroyed) {\n    return;\n  }\n  return writeFromReadableStreamDefaultReader(stream.getReader(), writable);\n}\nvar buildOutgoingHttpHeaders = (headers) => {\n  const res = {};\n  if (!(headers instanceof Headers)) {\n    headers = new Headers(headers ?? void 0);\n  }\n  const cookies = [];\n  for (const [k, v] of headers) {\n    if (k === \"set-cookie\") {\n      cookies.push(v);\n    } else {\n      res[k] = v;\n    }\n  }\n  if (cookies.length > 0) {\n    res[\"set-cookie\"] = cookies;\n  }\n  res[\"content-type\"] ??= \"text/plain; charset=UTF-8\";\n  return res;\n};\n\n// src/utils/response/constants.ts\nvar X_ALREADY_SENT = \"x-hono-already-sent\";\n\n// src/globals.ts\nimport crypto from \"crypto\";\nvar webFetch = global.fetch;\nif (typeof global.crypto === \"undefined\") {\n  global.crypto = crypto;\n}\nglobal.fetch = (info, init) => {\n  init = {\n    // Disable compression handling so people can return the result of a fetch\n    // directly in the loader without messing with the Content-Encoding header.\n    compress: false,\n    ...init\n  };\n  return webFetch(info, init);\n};\n\n// src/listener.ts\nvar outgoingEnded = Symbol(\"outgoingEnded\");\nvar handleRequestError = () => new Response(null, {\n  status: 400\n});\nvar handleFetchError = (e) => new Response(null, {\n  status: e instanceof Error && (e.name === \"TimeoutError\" || e.constructor.name === \"TimeoutError\") ? 504 : 500\n});\nvar handleResponseError = (e, outgoing) => {\n  const err = e instanceof Error ? e : new Error(\"unknown error\", { cause: e });\n  if (err.code === \"ERR_STREAM_PREMATURE_CLOSE\") {\n    console.info(\"The user aborted a request.\");\n  } else {\n    console.error(e);\n    if (!outgoing.headersSent) {\n      outgoing.writeHead(500, { \"Content-Type\": \"text/plain\" });\n    }\n    outgoing.end(`Error: ${err.message}`);\n    outgoing.destroy(err);\n  }\n};\nvar flushHeaders = (outgoing) => {\n  if (\"flushHeaders\" in outgoing && outgoing.writable) {\n    outgoing.flushHeaders();\n  }\n};\nvar responseViaCache = async (res, outgoing) => {\n  let [status, body, header] = res[cacheKey];\n  if (header instanceof Headers) {\n    header = buildOutgoingHttpHeaders(header);\n  }\n  if (typeof body === \"string\") {\n    header[\"Content-Length\"] = Buffer.byteLength(body);\n  } else if (body instanceof Uint8Array) {\n    header[\"Content-Length\"] = body.byteLength;\n  } else if (body instanceof Blob) {\n    header[\"Content-Length\"] = body.size;\n  }\n  outgoing.writeHead(status, header);\n  if (typeof body === \"string\" || body instanceof Uint8Array) {\n    outgoing.end(body);\n  } else if (body instanceof Blob) {\n    outgoing.end(new Uint8Array(await body.arrayBuffer()));\n  } else {\n    flushHeaders(outgoing);\n    await writeFromReadableStream(body, outgoing)?.catch(\n      (e) => handleResponseError(e, outgoing)\n    );\n  }\n  ;\n  outgoing[outgoingEnded]?.();\n};\nvar isPromise = (res) => typeof res.then === \"function\";\nvar responseViaResponseObject = async (res, outgoing, options = {}) => {\n  if (isPromise(res)) {\n    if (options.errorHandler) {\n      try {\n        res = await res;\n      } catch (err) {\n        const errRes = await options.errorHandler(err);\n        if (!errRes) {\n          return;\n        }\n        res = errRes;\n      }\n    } else {\n      res = await res.catch(handleFetchError);\n    }\n  }\n  if (cacheKey in res) {\n    return responseViaCache(res, outgoing);\n  }\n  const resHeaderRecord = buildOutgoingHttpHeaders(res.headers);\n  if (res.body) {\n    const reader = res.body.getReader();\n    const values = [];\n    let done = false;\n    let currentReadPromise = void 0;\n    if (resHeaderRecord[\"transfer-encoding\"] !== \"chunked\") {\n      let maxReadCount = 2;\n      for (let i = 0; i < maxReadCount; i++) {\n        currentReadPromise ||= reader.read();\n        const chunk = await readWithoutBlocking(currentReadPromise).catch((e) => {\n          console.error(e);\n          done = true;\n        });\n        if (!chunk) {\n          if (i === 1) {\n            await new Promise((resolve) => setTimeout(resolve));\n            maxReadCount = 3;\n            continue;\n          }\n          break;\n        }\n        currentReadPromise = void 0;\n        if (chunk.value) {\n          values.push(chunk.value);\n        }\n        if (chunk.done) {\n          done = true;\n          break;\n        }\n      }\n      if (done && !(\"content-length\" in resHeaderRecord)) {\n        resHeaderRecord[\"content-length\"] = values.reduce((acc, value) => acc + value.length, 0);\n      }\n    }\n    outgoing.writeHead(res.status, resHeaderRecord);\n    values.forEach((value) => {\n      ;\n      outgoing.write(value);\n    });\n    if (done) {\n      outgoing.end();\n    } else {\n      if (values.length === 0) {\n        flushHeaders(outgoing);\n      }\n      await writeFromReadableStreamDefaultReader(reader, outgoing, currentReadPromise);\n    }\n  } else if (resHeaderRecord[X_ALREADY_SENT]) {\n  } else {\n    outgoing.writeHead(res.status, resHeaderRecord);\n    outgoing.end();\n  }\n  ;\n  outgoing[outgoingEnded]?.();\n};\nvar getRequestListener = (fetchCallback, options = {}) => {\n  const autoCleanupIncoming = options.autoCleanupIncoming ?? true;\n  if (options.overrideGlobalObjects !== false && global.Request !== Request) {\n    Object.defineProperty(global, \"Request\", {\n      value: Request\n    });\n    Object.defineProperty(global, \"Response\", {\n      value: Response2\n    });\n  }\n  return async (incoming, outgoing) => {\n    let res, req;\n    try {\n      req = newRequest(incoming, options.hostname);\n      let incomingEnded = !autoCleanupIncoming || incoming.method === \"GET\" || incoming.method === \"HEAD\";\n      if (!incomingEnded) {\n        ;\n        incoming[wrapBodyStream] = true;\n        incoming.on(\"end\", () => {\n          incomingEnded = true;\n        });\n        if (incoming instanceof Http2ServerRequest2) {\n          ;\n          outgoing[outgoingEnded] = () => {\n            if (!incomingEnded) {\n              setTimeout(() => {\n                if (!incomingEnded) {\n                  setTimeout(() => {\n                    incoming.destroy();\n                    outgoing.destroy();\n                  });\n                }\n              });\n            }\n          };\n        }\n      }\n      outgoing.on(\"close\", () => {\n        const abortController = req[abortControllerKey];\n        if (abortController) {\n          if (incoming.errored) {\n            req[abortControllerKey].abort(incoming.errored.toString());\n          } else if (!outgoing.writableFinished) {\n            req[abortControllerKey].abort(\"Client connection prematurely closed.\");\n          }\n        }\n        if (!incomingEnded) {\n          setTimeout(() => {\n            if (!incomingEnded) {\n              setTimeout(() => {\n                incoming.destroy();\n              });\n            }\n          });\n        }\n      });\n      res = fetchCallback(req, { incoming, outgoing });\n      if (cacheKey in res) {\n        return responseViaCache(res, outgoing);\n      }\n    } catch (e) {\n      if (!res) {\n        if (options.errorHandler) {\n          res = await options.errorHandler(req ? e : toRequestError(e));\n          if (!res) {\n            return;\n          }\n        } else if (!req) {\n          res = handleRequestError();\n        } else {\n          res = handleFetchError(e);\n        }\n      } else {\n        return handleResponseError(e, outgoing);\n      }\n    }\n    try {\n      return await responseViaResponseObject(res, outgoing, options);\n    } catch (e) {\n      return handleResponseError(e, outgoing);\n    }\n  };\n};\n\n// src/server.ts\nvar createAdaptorServer = (options) => {\n  const fetchCallback = options.fetch;\n  const requestListener = getRequestListener(fetchCallback, {\n    hostname: options.hostname,\n    overrideGlobalObjects: options.overrideGlobalObjects,\n    autoCleanupIncoming: options.autoCleanupIncoming\n  });\n  const createServer = options.createServer || createServerHTTP;\n  const server = createServer(options.serverOptions || {}, requestListener);\n  return server;\n};\nvar serve = (options, listeningListener) => {\n  const server = createAdaptorServer(options);\n  server.listen(options?.port ?? 3e3, options.hostname, () => {\n    const serverInfo = server.address();\n    listeningListener && listeningListener(serverInfo);\n  });\n  return server;\n};\nexport {\n  RequestError,\n  createAdaptorServer,\n  getRequestListener,\n  serve\n};\n", "import { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { logger as honoLogger } from \"hono/logger\";\nimport { createRoutes } from \"./routes\";\nimport type { ServerConfig, ServerStatus } from \"./types\";\n\nlet serverInstance: any = null;\nlet serverStartTime: number | null = null;\nlet serverInfo: { port: number; host: string } | null = null;\n\nexport function createServer(): Hono {\n  const app = new Hono();\n\n  app.use(\"*\", cors());\n  app.use(\"*\", honoLogger());\n\n  app.get(\"/\", (c) => {\n    return c.json({\n      name: \"supercoin\",\n      version: \"0.1.0\",\n      status: \"running\",\n    });\n  });\n\n  app.route(\"/\", createRoutes());\n\n  app.notFound((c) => {\n    return c.json({ error: \"Not Found\" }, 404);\n  });\n\n  app.onError((err, c) => {\n    console.error(`[supercoin:server] Error: ${err.message}`);\n    return c.json({ error: err.message }, 500);\n  });\n\n  return app;\n}\n\nexport async function startServer(config: ServerConfig): Promise<ServerStatus> {\n  if (serverInstance) {\n    return getServerStatus();\n  }\n\n  const app = createServer();\n\n  if (typeof Bun !== \"undefined\") {\n    serverInstance = Bun.serve({\n      port: config.port,\n      hostname: config.host,\n      fetch: app.fetch,\n    });\n    serverInfo = { port: serverInstance.port, host: serverInstance.hostname };\n  } else {\n    serverInstance = serve({\n      fetch: app.fetch,\n      port: config.port,\n      hostname: config.host,\n    });\n    serverInfo = { port: config.port, host: config.host };\n  }\n\n  serverStartTime = Date.now();\n\n  return {\n    running: true,\n    port: serverInfo.port,\n    host: serverInfo.host,\n    pid: process.pid,\n    uptime: 0,\n  };\n}\n\nexport async function stopServer(): Promise<void> {\n  if (serverInstance) {\n    if (typeof Bun !== \"undefined\") {\n      serverInstance.stop();\n    } else {\n      serverInstance.close();\n    }\n    serverInstance = null;\n    serverStartTime = null;\n    serverInfo = null;\n  }\n}\n\nexport function getServerStatus(): ServerStatus {\n  if (!serverInstance || !serverInfo) {\n    return { running: false };\n  }\n\n  return {\n    running: true,\n    port: serverInfo.port,\n    host: serverInfo.host,\n    pid: process.pid,\n    uptime: serverStartTime ? Math.floor((Date.now() - serverStartTime) / 1000) : 0,\n  };\n}\n\nexport function isServerRunning(): boolean {\n  return serverInstance !== null;\n}\n\nexport { createRoutes } from \"./routes\";\nexport * from \"./types\";\n", "import { Hono } from \"hono\";\nimport { createHealthRoutes } from \"./health\";\nimport { createAuthCallbackRoutes } from \"./auth-callback\";\n\nexport function createRoutes(): Hono {\n  const app = new Hono();\n\n  app.route(\"/health\", createHealthRoutes());\n  app.route(\"/callback\", createAuthCallbackRoutes());\n\n  return app;\n}\n\nexport { createHealthRoutes } from \"./health\";\nexport { createAuthCallbackRoutes, callbackEmitter, waitForCallback } from \"./auth-callback\";\n", "import { Hono } from \"hono\";\n\nexport function createHealthRoutes(): Hono {\n  const app = new Hono();\n\n  app.get(\"/\", (c) => {\n    return c.json({\n      status: \"ok\",\n      timestamp: new Date().toISOString(),\n      version: \"0.1.0\",\n    });\n  });\n\n  app.get(\"/ready\", (c) => {\n    return c.json({\n      status: \"ready\",\n      timestamp: new Date().toISOString(),\n    });\n  });\n\n  return app;\n}\n", "import { Hono } from \"hono\";\nimport { html } from \"hono/html\";\nimport { EventEmitter } from \"events\";\nimport type { OAuthCallbackData } from \"../../services/auth/types\";\n\nexport const callbackEmitter = new EventEmitter();\n\nexport function createAuthCallbackRoutes(): Hono {\n  const app = new Hono();\n\n  app.get(\"/:provider\", async (c) => {\n    const provider = c.req.param(\"provider\");\n    const code = c.req.query(\"code\");\n    const state = c.req.query(\"state\");\n    const error = c.req.query(\"error\");\n    const errorDescription = c.req.query(\"error_description\");\n\n    if (error) {\n      const callbackData: OAuthCallbackData = {\n        code: \"\",\n        state: state || \"\",\n        error,\n        errorDescription,\n      };\n\n      callbackEmitter.emit(`callback:${provider}`, {\n        success: false,\n        provider,\n        ...callbackData,\n      });\n\n      return c.html(html`\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <title>Authentication Failed</title>\n            <style>\n              body {\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                height: 100vh;\n                margin: 0;\n                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n                color: #fff;\n              }\n              .container {\n                text-align: center;\n                padding: 40px;\n                background: rgba(255,255,255,0.1);\n                border-radius: 12px;\n                backdrop-filter: blur(10px);\n              }\n              h1 { color: #ff6b6b; margin-bottom: 16px; }\n              p { color: #ddd; margin: 8px 0; }\n              .error { color: #ff6b6b; font-size: 14px; }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <h1>\u274C Authentication Failed</h1>\n              <p>Provider: <strong>${provider}</strong></p>\n              <p class=\"error\">${errorDescription || error}</p>\n              <p>You can close this window.</p>\n            </div>\n            <script>setTimeout(() => window.close(), 5000);</script>\n          </body>\n        </html>\n      `);\n    }\n\n    if (!code) {\n      return c.html(html`\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <title>Authentication Error</title>\n            <style>\n              body {\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                height: 100vh;\n                margin: 0;\n                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n                color: #fff;\n              }\n              .container {\n                text-align: center;\n                padding: 40px;\n                background: rgba(255,255,255,0.1);\n                border-radius: 12px;\n              }\n              h1 { color: #ff6b6b; }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <h1>\u274C Missing Authorization Code</h1>\n              <p>The authorization code was not received.</p>\n            </div>\n          </body>\n        </html>\n      `);\n    }\n\n    if (!state) {\n      return c.html(html`\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <title>Security Error</title>\n            <style>\n              body {\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                height: 100vh;\n                margin: 0;\n                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n                color: #fff;\n              }\n              .container {\n                text-align: center;\n                padding: 40px;\n                background: rgba(255,255,255,0.1);\n                border-radius: 12px;\n              }\n              h1 { color: #ff6b6b; }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <h1>\uD83D\uDEE1\uFE0F Security Error</h1>\n              <p>Missing state parameter (CSRF protection).</p>\n            </div>\n          </body>\n        </html>\n      `);\n    }\n\n    const callbackData: OAuthCallbackData = {\n      code,\n      state,\n    };\n\n    callbackEmitter.emit(`callback:${provider}`, {\n      success: true,\n      provider,\n      ...callbackData,\n    });\n\n    return c.html(html`\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Authentication Successful</title>\n          <style>\n            body {\n              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n              display: flex;\n              justify-content: center;\n              align-items: center;\n              height: 100vh;\n              margin: 0;\n              background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n              color: #fff;\n            }\n            .container {\n              text-align: center;\n              padding: 40px;\n              background: rgba(255,255,255,0.1);\n              border-radius: 12px;\n              backdrop-filter: blur(10px);\n            }\n            h1 { color: #4ade80; margin-bottom: 16px; }\n            p { color: #ddd; }\n            .spinner {\n              width: 40px;\n              height: 40px;\n              border: 4px solid rgba(255,255,255,0.3);\n              border-top: 4px solid #4ade80;\n              border-radius: 50%;\n              animation: spin 1s linear infinite;\n              margin: 20px auto;\n            }\n            @keyframes spin {\n              0% { transform: rotate(0deg); }\n              100% { transform: rotate(360deg); }\n            }\n          </style>\n        </head>\n        <body>\n          <div class=\"container\">\n            <h1>\u2705 Authentication Successful!</h1>\n            <p>Provider: <strong>${provider}</strong></p>\n            <div class=\"spinner\"></div>\n            <p>Processing... You can close this window.</p>\n          </div>\n          <script>setTimeout(() => window.close(), 3000);</script>\n        </body>\n      </html>\n    `);\n  });\n\n  return app;\n}\n\nexport function waitForCallback(\n  provider: string,\n  timeoutMs: number = 120000\n): Promise<OAuthCallbackData> {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      callbackEmitter.removeAllListeners(`callback:${provider}`);\n      reject(new Error(`OAuth callback timeout for ${provider}`));\n    }, timeoutMs);\n\n    callbackEmitter.once(`callback:${provider}`, (result) => {\n      clearTimeout(timer);\n      if (result.success) {\n        resolve({ code: result.code, state: result.state });\n      } else {\n        reject(new Error(result.errorDescription || result.error || \"OAuth failed\"));\n      }\n    });\n  });\n}\n", "/**\n * Auth Hub\n * Unified authentication manager for all providers\n */\nimport { ClaudeAuthProvider } from \"./claude\";\nimport { CodexAuthProvider } from \"./codex\";\nimport { GeminiAuthProvider } from \"./gemini\";\nimport { getTokenStore } from \"../../server/store/token-store\";\nimport type {\n  AuthProvider,\n  AuthProviderName,\n  AuthResult,\n  AuthStatus,\n  LoginOptions,\n  TokenData,\n} from \"./types\";\nimport logger from \"../../shared/logger\";\n\nexport class AuthHub {\n  private providers: Map<AuthProviderName, AuthProvider>;\n  private tokenStore = getTokenStore();\n\n  constructor() {\n    this.providers = new Map<AuthProviderName, AuthProvider>([\n      [\"claude\", new ClaudeAuthProvider()],\n      [\"codex\", new CodexAuthProvider()],\n      [\"gemini\", new GeminiAuthProvider()],\n    ]);\n  }\n\n  /**\n   * Login to specific provider or interactively select\n   */\n  async login(\n    providerName?: AuthProviderName,\n    options?: LoginOptions\n  ): Promise<AuthResult[]> {\n    const results: AuthResult[] = [];\n\n    if (providerName) {\n      const provider = this.providers.get(providerName);\n      if (!provider) {\n        return [{ success: false, error: `Unknown provider: ${providerName}` }];\n      }\n      return [await provider.login(options)];\n    }\n\n    for (const [name, provider] of this.providers) {\n      const result = await provider.login(options);\n      results.push({ ...result, provider: name });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get authentication status for all providers\n   */\n  async status(): Promise<AuthStatus[]> {\n    const statuses: AuthStatus[] = [];\n\n    for (const [name, provider] of this.providers) {\n      const allTokens = await this.tokenStore.retrieveAll(name);\n      \n      if (allTokens.length === 0) {\n        statuses.push({\n          provider: name,\n          displayName: provider.displayName,\n          authenticated: false,\n          accountCount: 0,\n        });\n      } else {\n        for (const tokens of allTokens) {\n          const isAuthenticated = await provider.isAuthenticated(tokens.accountId);\n          statuses.push({\n            provider: name,\n            displayName: provider.displayName,\n            authenticated: isAuthenticated,\n            type: tokens.type,\n            expiresAt: tokens.expiresAt,\n            accountId: tokens.accountId,\n            accountCount: allTokens.length,\n            needsRefresh: tokens.type === \"oauth\"\n              ? await this.tokenStore.needsRefresh(name, tokens.accountId)\n              : false,\n          });\n        }\n      }\n    }\n\n    return statuses;\n  }\n\n  /**\n   * Refresh tokens for specific provider or all\n   */\n  async refresh(providerName?: AuthProviderName, accountId?: string): Promise<AuthResult[]> {\n    const results: AuthResult[] = [];\n\n    const providers = providerName\n      ? [[providerName, this.providers.get(providerName)!]]\n      : Array.from(this.providers.entries());\n\n    for (const [name, provider] of providers as [AuthProviderName, AuthProvider][]) {\n      if (provider?.refresh) {\n        try {\n          await provider.refresh(accountId);\n          results.push({ success: true, provider: name, accountId });\n        } catch (error) {\n          results.push({\n            success: false,\n            provider: name,\n            accountId,\n            error: (error as Error).message,\n          });\n        }\n      } else {\n        results.push({\n          success: true,\n          provider: name,\n          accountId,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Logout from specific provider or all\n   */\n  async logout(providerName?: AuthProviderName, accountId?: string): Promise<void> {\n    if (providerName) {\n      const provider = this.providers.get(providerName);\n      if (provider) {\n        await provider.logout(accountId);\n      }\n      return;\n    }\n\n    for (const provider of this.providers.values()) {\n      await provider.logout(accountId);\n    }\n  }\n\n  /**\n   * Get token for specific provider\n   */\n  async getToken(providerName: AuthProviderName, accountId?: string): Promise<string | null> {\n    const provider = this.providers.get(providerName);\n    if (!provider) return null;\n    return provider.getToken(accountId);\n  }\n\n  /**\n   * Check if specific provider is authenticated\n   */\n  async isAuthenticated(providerName: AuthProviderName, accountId?: string): Promise<boolean> {\n    const provider = this.providers.get(providerName);\n    if (!provider) return false;\n    return provider.isAuthenticated(accountId);\n  }\n\n  /**\n   * Get provider instance\n   */\n  getProvider(providerName: AuthProviderName): AuthProvider | undefined {\n    return this.providers.get(providerName);\n  }\n\n  /**\n   * Map model provider to auth provider name\n   */\n  mapModelProviderToAuth(modelProvider: string): AuthProviderName | null {\n    const mapping: Record<string, AuthProviderName> = {\n      anthropic: \"claude\",\n      openai: \"codex\",\n      google: \"gemini\",\n    };\n    return mapping[modelProvider] || null;\n  }\n}\n\n// Singleton instance\nlet authHubInstance: AuthHub | null = null;\n\nexport function getAuthHub(): AuthHub {\n  if (!authHubInstance) {\n    authHubInstance = new AuthHub();\n  }\n  return authHubInstance;\n}\n", "/**\n * Custom Error Classes\n */\n\nexport class SuperCoinError extends Error {\n  public readonly code: string;\n  public readonly details?: unknown;\n\n  constructor(message: string, code: string, details?: unknown) {\n    super(message);\n    this.name = \"SuperCoinError\";\n    this.code = code;\n    this.details = details;\n  }\n}\n\nexport class AuthError extends SuperCoinError {\n  constructor(message: string, provider?: string) {\n    super(message, \"AUTH_ERROR\", { provider });\n    this.name = \"AuthError\";\n  }\n}\n\nexport class ModelError extends SuperCoinError {\n  constructor(message: string, model?: string) {\n    super(message, \"MODEL_ERROR\", { model });\n    this.name = \"ModelError\";\n  }\n}\n\nexport class ConfigError extends SuperCoinError {\n  constructor(message: string, path?: string) {\n    super(message, \"CONFIG_ERROR\", { path });\n    this.name = \"ConfigError\";\n  }\n}\n\nexport class NetworkError extends SuperCoinError {\n  constructor(message: string, url?: string) {\n    super(message, \"NETWORK_ERROR\", { url });\n    this.name = \"NetworkError\";\n  }\n}\n\nexport class AgentError extends SuperCoinError {\n  constructor(message: string, agent?: string) {\n    super(message, \"AGENT_ERROR\", { agent });\n    this.name = \"AgentError\";\n  }\n}\n", "import type {\n  Provider,\n  ModelDefinition,\n  AIRequest,\n  AIResponse,\n  ModelConfig,\n  Message,\n  ToolDefinition,\n} from \"../types\";\nimport { NetworkError } from \"../../../shared/errors\";\nimport logger from \"../../../shared/logger\";\n\ninterface AnthropicMessage {\n  role: \"user\" | \"assistant\";\n  content: string | AnthropicContentBlock[];\n}\n\ninterface AnthropicContentBlock {\n  type: \"text\" | \"tool_use\";\n  text?: string;\n  id?: string;\n  name?: string;\n  input?: Record<string, unknown>;\n}\n\ninterface AnthropicTool {\n  name: string;\n  description: string;\n  input_schema: Record<string, unknown>;\n}\n\ninterface AnthropicResponse {\n  content: AnthropicContentBlock[];\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n  stop_reason: string;\n}\n\nexport class AnthropicProvider implements Provider {\n  readonly name = \"anthropic\" as const;\n  private readonly baseUrl = \"https://api.anthropic.com/v1\";\n\n  private readonly models: ModelDefinition[] = [\n    {\n      id: \"claude-opus-4-5\",\n      name: \"Claude Opus 4.5\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\"],\n      pricing: { input: 15.0, output: 75.0 },\n    },\n    {\n      id: \"claude-sonnet-4-5\",\n      name: \"Claude Sonnet 4.5\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\"],\n      pricing: { input: 3.0, output: 15.0 },\n    },\n    {\n      id: \"claude-haiku-4-5\",\n      name: \"Claude Haiku 4.5\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\"],\n      pricing: { input: 0.8, output: 4.0 },\n    },\n    {\n      id: \"claude-sonnet-4\",\n      name: \"Claude Sonnet 4\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\"],\n      pricing: { input: 3.0, output: 15.0 },\n    },\n    {\n      id: \"claude-haiku-3-5\",\n      name: \"Claude Haiku 3.5\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\"],\n      pricing: { input: 0.8, output: 4.0 },\n    },\n  ];\n\n  isValidModel(model: string): boolean {\n    return this.models.some((m) => m.id === model);\n  }\n\n  listModels(): ModelDefinition[] {\n    return this.models;\n  }\n\n  getModelInfo(model: string): ModelDefinition | null {\n    return this.models.find((m) => m.id === model) || null;\n  }\n\n  async complete(\n    request: AIRequest,\n    config: ModelConfig,\n    token: string\n  ): Promise<AIResponse> {\n    const response = await fetch(`${this.baseUrl}/messages`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-api-key\": token,\n        \"anthropic-version\": \"2023-06-01\",\n      },\n      body: JSON.stringify({\n        model: config.model,\n        max_tokens: config.maxTokens || 4096,\n        temperature: config.temperature ?? 0.7,\n        system: request.systemPrompt,\n        messages: this.convertMessages(request.messages),\n        tools: request.tools ? this.convertTools(request.tools) : undefined,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: { message?: string } };\n      const message = error.error?.message || response.statusText;\n      logger.error(`Anthropic API request failed`, new Error(message));\n      throw new NetworkError(`Anthropic API error: ${message}`, \"https://api.anthropic.com\");\n    }\n\n    const data = await response.json() as AnthropicResponse;\n    return this.convertResponse(data, config.model);\n  }\n\n  private convertMessages(messages: Message[]): AnthropicMessage[] {\n    return messages\n      .filter((m) => m.role !== \"system\")\n      .map((m) => ({\n        role: m.role as \"user\" | \"assistant\",\n        content: m.content,\n      }));\n  }\n\n  private convertTools(tools: ToolDefinition[]): AnthropicTool[] {\n    return tools.map((t) => ({\n      name: t.name,\n      description: t.description,\n      input_schema: t.parameters,\n    }));\n  }\n\n  private convertResponse(data: AnthropicResponse, model: string): AIResponse {\n    const textContent = data.content.find((c) => c.type === \"text\");\n    const toolUseContent = data.content.filter((c) => c.type === \"tool_use\");\n\n    return {\n      content: textContent?.text || \"\",\n      toolCalls: toolUseContent.map((t) => ({\n        id: t.id || \"\",\n        name: t.name || \"\",\n        arguments: t.input || {},\n      })),\n      usage: {\n        promptTokens: data.usage.input_tokens,\n        completionTokens: data.usage.output_tokens,\n        totalTokens: data.usage.input_tokens + data.usage.output_tokens,\n      },\n      model,\n      finishReason: data.stop_reason === \"end_turn\" ? \"stop\" : \"tool_calls\",\n    };\n  }\n}\n", "import type {\n  Provider,\n  ModelDefinition,\n  AIRequest,\n  AIResponse,\n  ModelConfig,\n  Message,\n  ToolDefinition,\n} from \"../types\";\nimport { NetworkError } from \"../../../shared/errors\";\nimport logger from \"../../../shared/logger\";\n\ninterface OpenAIMessage {\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n}\n\ninterface OpenAITool {\n  type: \"function\";\n  function: {\n    name: string;\n    description: string;\n    parameters: Record<string, unknown>;\n  };\n}\n\ninterface OpenAIToolCall {\n  id: string;\n  function: {\n    name: string;\n    arguments: string;\n  };\n}\n\ninterface OpenAIResponse {\n  choices: Array<{\n    message: {\n      content: string | null;\n      tool_calls?: OpenAIToolCall[];\n    };\n    finish_reason: string;\n  }>;\n  usage: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\nexport class OpenAIProvider implements Provider {\n  readonly name = \"openai\" as const;\n  private readonly baseUrl = \"https://api.openai.com/v1\";\n\n  private readonly models: ModelDefinition[] = [\n    {\n      id: \"gpt-5.2\",\n      name: \"GPT-5.2\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\", \"reasoning\"],\n      pricing: { input: 5.0, output: 15.0 },\n    },\n    {\n      id: \"o3\",\n      name: \"o3\",\n      contextWindow: 200000,\n      capabilities: [\"chat\", \"reasoning\"],\n      pricing: { input: 15.0, output: 60.0 },\n    },\n    {\n      id: \"o1\",\n      name: \"o1\",\n      contextWindow: 128000,\n      capabilities: [\"chat\", \"reasoning\"],\n      pricing: { input: 15.0, output: 60.0 },\n    },\n    {\n      id: \"o1-mini\",\n      name: \"o1-mini\",\n      contextWindow: 128000,\n      capabilities: [\"chat\", \"reasoning\", \"coding\"],\n      pricing: { input: 3.0, output: 12.0 },\n    },\n    {\n      id: \"gpt-4o\",\n      name: \"GPT-4o\",\n      contextWindow: 128000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\"],\n      pricing: { input: 2.5, output: 10.0 },\n    },\n  ];\n\n  isValidModel(model: string): boolean {\n    return this.models.some((m) => m.id === model);\n  }\n\n  listModels(): ModelDefinition[] {\n    return this.models;\n  }\n\n  getModelInfo(model: string): ModelDefinition | null {\n    return this.models.find((m) => m.id === model) || null;\n  }\n\n  async complete(\n    request: AIRequest,\n    config: ModelConfig,\n    token: string\n  ): Promise<AIResponse> {\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n      body: JSON.stringify({\n        model: config.model,\n        messages: this.convertMessages(request.messages, request.systemPrompt),\n        max_tokens: config.maxTokens || 4096,\n        temperature: config.temperature ?? 0.7,\n        tools: request.tools ? this.convertTools(request.tools) : undefined,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: { message?: string } };\n      const message = error.error?.message || response.statusText;\n      logger.error(`OpenAI API request failed`, new Error(message));\n      throw new NetworkError(`OpenAI API error: ${message}`, \"https://api.openai.com\");\n    }\n\n    const data = await response.json() as OpenAIResponse;\n    return this.convertResponse(data, config.model);\n  }\n\n  private convertMessages(messages: Message[], systemPrompt?: string): OpenAIMessage[] {\n    const converted: OpenAIMessage[] = [];\n\n    if (systemPrompt) {\n      converted.push({ role: \"system\", content: systemPrompt });\n    }\n\n    for (const m of messages) {\n      converted.push({ role: m.role, content: m.content });\n    }\n\n    return converted;\n  }\n\n  private convertTools(tools: ToolDefinition[]): OpenAITool[] {\n    return tools.map((t) => ({\n      type: \"function\" as const,\n      function: {\n        name: t.name,\n        description: t.description,\n        parameters: t.parameters,\n      },\n    }));\n  }\n\n  private convertResponse(data: OpenAIResponse, model: string): AIResponse {\n    const choice = data.choices[0];\n    const message = choice.message;\n\n    return {\n      content: message.content || \"\",\n      toolCalls: message.tool_calls?.map((t) => ({\n        id: t.id,\n        name: t.function.name,\n        arguments: JSON.parse(t.function.arguments),\n      })),\n      usage: {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens,\n      },\n      model,\n      finishReason: choice.finish_reason === \"stop\" ? \"stop\" : \"tool_calls\",\n    };\n  }\n}\n", "import type {\n  Provider,\n  ModelDefinition,\n  AIRequest,\n  AIResponse,\n  ModelConfig,\n  Message,\n  ToolDefinition,\n} from \"../types\";\nimport { NetworkError } from \"../../../shared/errors\";\nimport logger from \"../../../shared/logger\";\n\ninterface GeminiContent {\n  role: \"user\" | \"model\";\n  parts: Array<{ text: string }>;\n}\n\ninterface GeminiTool {\n  functionDeclarations: Array<{\n    name: string;\n    description: string;\n    parameters: Record<string, unknown>;\n  }>;\n}\n\ninterface GeminiFunctionCall {\n  functionCall: {\n    name: string;\n    args: Record<string, unknown>;\n  };\n}\n\ninterface GeminiResponse {\n  candidates: Array<{\n    content: {\n      parts: Array<{ text?: string; functionCall?: { name: string; args: Record<string, unknown> } }>;\n    };\n    finishReason: string;\n  }>;\n  usageMetadata?: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n  };\n}\n\nexport class GoogleProvider implements Provider {\n  readonly name = \"google\" as const;\n  private readonly baseUrl = \"https://generativelanguage.googleapis.com/v1beta\";\n\n  private readonly models: ModelDefinition[] = [\n    {\n      id: \"gemini-3-pro\",\n      name: \"Gemini 3 Pro\",\n      contextWindow: 2000000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\", \"long_context\"],\n      pricing: { input: 1.25, output: 5.0 },\n    },\n    {\n      id: \"gemini-3-flash\",\n      name: \"Gemini 3 Flash\",\n      contextWindow: 1000000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\", \"long_context\"],\n      pricing: { input: 0.075, output: 0.3 },\n    },\n    {\n      id: \"gemini-2.0-flash\",\n      name: \"Gemini 2.0 Flash\",\n      contextWindow: 1000000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\", \"long_context\"],\n      pricing: { input: 0.075, output: 0.3 },\n    },\n    {\n      id: \"gemini-2.0-pro\",\n      name: \"Gemini 2.0 Pro\",\n      contextWindow: 1000000,\n      capabilities: [\"chat\", \"vision\", \"function_calling\", \"long_context\"],\n      pricing: { input: 1.25, output: 5.0 },\n    },\n  ];\n\n  isValidModel(model: string): boolean {\n    return this.models.some((m) => m.id === model);\n  }\n\n  listModels(): ModelDefinition[] {\n    return this.models;\n  }\n\n  getModelInfo(model: string): ModelDefinition | null {\n    return this.models.find((m) => m.id === model) || null;\n  }\n\n  async complete(\n    request: AIRequest,\n    config: ModelConfig,\n    token: string\n  ): Promise<AIResponse> {\n    const modelPath = `models/${config.model}`;\n    const url = `${this.baseUrl}/${modelPath}:generateContent?key=${token}`;\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        contents: this.convertMessages(request.messages),\n        systemInstruction: request.systemPrompt\n          ? { parts: [{ text: request.systemPrompt }] }\n          : undefined,\n        generationConfig: {\n          maxOutputTokens: config.maxTokens || 8192,\n          temperature: config.temperature ?? 0.7,\n        },\n        tools: request.tools ? this.convertTools(request.tools) : undefined,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: { message?: string } };\n      const message = error.error?.message || response.statusText;\n      logger.error(`Google AI API request failed`, new Error(message));\n      throw new NetworkError(`Google AI API error: ${message}`, \"https://generativelanguage.googleapis.com\");\n    }\n\n    const data = await response.json() as GeminiResponse;\n    return this.convertResponse(data, config.model);\n  }\n\n  private convertMessages(messages: Message[]): GeminiContent[] {\n    return messages\n      .filter((m) => m.role !== \"system\")\n      .map((m) => ({\n        role: m.role === \"assistant\" ? \"model\" as const : \"user\" as const,\n        parts: [{ text: m.content }],\n      }));\n  }\n\n  private convertTools(tools: ToolDefinition[]): GeminiTool[] {\n    return [\n      {\n        functionDeclarations: tools.map((t) => ({\n          name: t.name,\n          description: t.description,\n          parameters: t.parameters,\n        })),\n      },\n    ];\n  }\n\n  private convertResponse(data: GeminiResponse, model: string): AIResponse {\n    const candidate = data.candidates[0];\n    const content = candidate.content;\n    const textPart = content.parts.find((p) => p.text);\n    const functionCalls = content.parts.filter((p) => p.functionCall);\n\n    return {\n      content: textPart?.text || \"\",\n      toolCalls: functionCalls.map((fc) => ({\n        id: crypto.randomUUID(),\n        name: fc.functionCall!.name,\n        arguments: fc.functionCall!.args,\n      })),\n      usage: {\n        promptTokens: data.usageMetadata?.promptTokenCount || 0,\n        completionTokens: data.usageMetadata?.candidatesTokenCount || 0,\n        totalTokens: data.usageMetadata?.totalTokenCount || 0,\n      },\n      model,\n      finishReason:\n        candidate.finishReason === \"STOP\"\n          ? \"stop\"\n          : candidate.finishReason === \"FUNCTION_CALL\"\n          ? \"tool_calls\"\n          : \"stop\",\n    };\n  }\n}\n", "import { getAuthHub } from \"../auth/hub\";\nimport type { AuthProviderName } from \"../auth/types\";\nimport { AnthropicProvider, OpenAIProvider, GoogleProvider } from \"./providers\";\nimport type {\n  Provider,\n  ProviderName,\n  ModelConfig,\n  ModelInfo,\n  AIRequest,\n  AIResponse,\n  RouterConfig,\n} from \"./types\";\nimport logger from \"../../shared/logger\";\n\nexport class ModelRouter {\n  private providers: Map<ProviderName, Provider>;\n  private currentModel: ModelConfig;\n  private fallbackChain: string[];\n  private modelAliases: Map<string, string>;\n\n  constructor(config: RouterConfig) {\n    this.providers = new Map<ProviderName, Provider>([\n      [\"anthropic\", new AnthropicProvider()],\n      [\"openai\", new OpenAIProvider()],\n      [\"google\", new GoogleProvider()],\n    ]);\n    this.fallbackChain = config.fallbackModels || [];\n    this.currentModel = this.parseModelId(config.defaultModel);\n    this.modelAliases = this.buildAliasMap();\n  }\n\n  async route(\n    request: AIRequest,\n    options?: { fallback?: boolean; retries?: number; timeout?: number }\n  ): Promise<AIResponse> {\n    const authHub = getAuthHub();\n    const modelConfig = this.currentModel;\n    const provider = this.providers.get(modelConfig.provider);\n\n    if (!provider) {\n      throw new Error(`Unknown provider: ${modelConfig.provider}`);\n    }\n\n    const authName = this.mapProviderToAuth(modelConfig.provider);\n    const isAuthenticated = await authHub.isAuthenticated(authName);\n    if (!isAuthenticated) {\n      throw new Error(\n        `Not authenticated with ${modelConfig.provider}. ` +\n        `Run: supercoin auth login --${authName}`\n      );\n    }\n\n    const token = await authHub.getToken(authName);\n    if (!token) {\n      throw new Error(`No token available for ${modelConfig.provider}`);\n    }\n\n    try {\n      return await this.executeWithRetry(\n        () => provider.complete(request, modelConfig, token),\n        options?.retries || 3,\n        options?.timeout || 60000\n      );\n    } catch (error) {\n      if (options?.fallback !== false && this.shouldFallback(error as Error)) {\n        return await this.fallbackRoute(request, options);\n      }\n      throw error;\n    }\n  }\n\n  async setModel(modelId: string): Promise<void> {\n    const authHub = getAuthHub();\n    const resolvedId = this.resolveAlias(modelId);\n    const modelConfig = this.parseModelId(resolvedId);\n\n    const provider = this.providers.get(modelConfig.provider);\n    if (!provider) {\n      throw new Error(`Unknown provider: ${modelConfig.provider}`);\n    }\n\n    const isValidModel = provider.isValidModel(modelConfig.model);\n    if (!isValidModel) {\n      const models = provider.listModels().map((m) => m.id);\n      throw new Error(\n        `Unknown model: ${modelConfig.model}. ` +\n        `Available models for ${modelConfig.provider}: ${models.join(\", \")}`\n      );\n    }\n\n    const authName = this.mapProviderToAuth(modelConfig.provider);\n    const isAuthenticated = await authHub.isAuthenticated(authName);\n    if (!isAuthenticated) {\n      throw new Error(\n        `Not authenticated with ${modelConfig.provider}. ` +\n        `Run: supercoin auth login --${authName}`\n      );\n    }\n\n    this.currentModel = modelConfig;\n  }\n\n  getCurrentModel(): ModelConfig {\n    return { ...this.currentModel };\n  }\n\n  listModels(): ModelInfo[] {\n    const models: ModelInfo[] = [];\n\n    for (const [providerName, provider] of this.providers) {\n      for (const model of provider.listModels()) {\n        models.push({\n          ...model,\n          id: `${providerName}/${model.id}`,\n          provider: providerName,\n        });\n      }\n    }\n\n    return models;\n  }\n\n  getModelInfo(modelId: string): ModelInfo | null {\n    try {\n      const resolvedId = this.resolveAlias(modelId);\n      const parsed = this.tryParseModelId(resolvedId);\n      if (!parsed) return null;\n\n      const { provider: providerName, model } = parsed;\n      const provider = this.providers.get(providerName);\n\n      if (!provider) return null;\n\n      const modelInfo = provider.getModelInfo(model);\n      if (!modelInfo) return null;\n\n      return {\n        ...modelInfo,\n        id: `${providerName}/${model}`,\n        provider: providerName,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  private tryParseModelId(modelId: string): ModelConfig | null {\n    const parts = modelId.split(\"/\");\n    if (parts.length !== 2) {\n      return null;\n    }\n    return { provider: parts[0] as ProviderName, model: parts[1] };\n  }\n\n  private async fallbackRoute(\n    request: AIRequest,\n    options?: { fallback?: boolean; retries?: number; timeout?: number }\n  ): Promise<AIResponse> {\n    const authHub = getAuthHub();\n\n    for (const modelId of this.fallbackChain) {\n      const modelConfig = this.parseModelId(modelId);\n      const provider = this.providers.get(modelConfig.provider);\n\n      if (!provider) continue;\n\n      const authName = this.mapProviderToAuth(modelConfig.provider);\n      const isAuthenticated = await authHub.isAuthenticated(authName);\n      if (!isAuthenticated) continue;\n\n      try {\n        const token = await authHub.getToken(authName);\n        if (!token) continue;\n\n        logger.info(`Falling back to ${modelId}...`);\n        return await provider.complete(request, modelConfig, token);\n      } catch {\n        continue;\n      }\n    }\n\n    throw new Error(\"All fallback models failed\");\n  }\n\n  private parseModelId(modelId: string): ModelConfig {\n    const parts = modelId.split(\"/\");\n    if (parts.length !== 2) {\n      throw new Error(`Invalid model ID format: ${modelId}. Expected: provider/model`);\n    }\n    return { provider: parts[0] as ProviderName, model: parts[1] };\n  }\n\n  private resolveAlias(modelId: string): string {\n    if (this.modelAliases.has(modelId)) {\n      return this.modelAliases.get(modelId)!;\n    }\n    return modelId;\n  }\n\n  private buildAliasMap(): Map<string, string> {\n    return new Map([\n      [\"claude-opus\", \"anthropic/claude-opus-4-5\"],\n      [\"opus\", \"anthropic/claude-opus-4-5\"],\n      [\"claude-sonnet\", \"anthropic/claude-sonnet-4-5\"],\n      [\"sonnet\", \"anthropic/claude-sonnet-4-5\"],\n      [\"claude-haiku\", \"anthropic/claude-haiku-4-5\"],\n      [\"haiku\", \"anthropic/claude-haiku-4-5\"],\n      [\"claude\", \"anthropic/claude-sonnet-4-5\"],\n\n      [\"gpt-5.2\", \"openai/gpt-5.2\"],\n      [\"gpt-5\", \"openai/gpt-5.2\"],\n      [\"gpt-4o\", \"openai/gpt-4o\"],\n      [\"4o\", \"openai/gpt-4o\"],\n      [\"gpt\", \"openai/gpt-5.2\"],\n      [\"o1\", \"openai/o1\"],\n      [\"o1-mini\", \"openai/o1-mini\"],\n      [\"o3\", \"openai/o3\"],\n\n      [\"gemini-flash\", \"google/gemini-3-flash\"],\n      [\"flash\", \"google/gemini-3-flash\"],\n      [\"gemini-pro\", \"google/gemini-3-pro\"],\n      [\"gemini\", \"google/gemini-3-flash\"],\n    ]);\n  }\n\n  private mapProviderToAuth(provider: ProviderName): AuthProviderName {\n    const map: Record<ProviderName, AuthProviderName> = {\n      anthropic: \"claude\",\n      openai: \"codex\",\n      google: \"gemini\",\n    };\n    return map[provider];\n  }\n\n  private shouldFallback(error: Error): boolean {\n    const fallbackErrors = [\n      \"rate_limit_exceeded\",\n      \"model_overloaded\",\n      \"server_error\",\n      \"timeout\",\n    ];\n    return fallbackErrors.some((e) => error.message?.includes(e));\n  }\n\n  private async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    retries: number,\n    timeout: number\n  ): Promise<T> {\n    let lastError: Error = new Error(\"Unknown error\");\n\n    for (let i = 0; i < retries; i++) {\n      try {\n        return await Promise.race([\n          fn(),\n          new Promise<never>((_, reject) =>\n            setTimeout(() => reject(new Error(\"timeout\")), timeout)\n          ),\n        ]);\n      } catch (error) {\n        lastError = error as Error;\n        if (i < retries - 1) {\n          await this.delay(Math.pow(2, i) * 1000);\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\nlet routerInstance: ModelRouter | null = null;\n\nexport function getModelRouter(config?: RouterConfig): ModelRouter {\n  if (!routerInstance || config) {\n    const defaultConfig: RouterConfig = config || {\n      defaultModel: \"anthropic/claude-sonnet-4-5\",\n      fallbackModels: [\"openai/gpt-5.2\", \"google/gemini-3-flash\"],\n    };\n    routerInstance = new ModelRouter(defaultConfig);\n  }\n  return routerInstance;\n}\n\nexport function resetModelRouter(): void {\n  routerInstance = null;\n}\n", "import type { Agent, AgentName } from \"./types\";\n\nexport interface IAgentRegistry {\n  register(agent: Agent): void;\n  get(name: AgentName): Agent | undefined;\n  has(name: AgentName): boolean;\n  list(): Agent[];\n  listNames(): AgentName[];\n}\n\nclass AgentRegistry implements IAgentRegistry {\n  private agents: Map<AgentName, Agent> = new Map();\n\n  register(agent: Agent): void {\n    this.agents.set(agent.name, agent);\n  }\n\n  get(name: AgentName): Agent | undefined {\n    return this.agents.get(name);\n  }\n\n  has(name: AgentName): boolean {\n    return this.agents.has(name);\n  }\n\n  list(): Agent[] {\n    return Array.from(this.agents.values());\n  }\n\n  listNames(): AgentName[] {\n    return Array.from(this.agents.keys());\n  }\n}\n\nlet registryInstance: AgentRegistry | null = null;\n\nexport function getAgentRegistry(): IAgentRegistry {\n  if (!registryInstance) {\n    registryInstance = new AgentRegistry();\n  }\n  return registryInstance;\n}\n", "export * from \"./types\";\nexport { getAgentRegistry, type IAgentRegistry } from \"./registry\";\nexport { getTodoManager, type ITodoManager } from \"./todo-manager\";\nexport { getBackgroundManager, type IBackgroundManager, type ISpawnInput } from \"./background\";\nexport { Coin, classifyRequest } from \"./coin\";\nexport { ExplorerAgent } from \"./explorer\";\nexport { AnalystAgent } from \"./analyst\";\nexport { ExecutorAgent } from \"./executor\";\nexport { CodeReviewerAgent } from \"./code-reviewer\";\nexport { DocWriterAgent } from \"./doc-writer\";\n\nimport { getAgentRegistry } from \"./registry\";\nimport { Coin } from \"./coin\";\nimport { ExplorerAgent } from \"./explorer\";\nimport { AnalystAgent } from \"./analyst\";\nimport { ExecutorAgent } from \"./executor\";\nimport { CodeReviewerAgent } from \"./code-reviewer\";\nimport { DocWriterAgent } from \"./doc-writer\";\n\nexport function initializeAgents(): void {\n  const registry = getAgentRegistry();\n\n  registry.register(new Coin());\n  registry.register(new ExplorerAgent());\n  registry.register(new AnalystAgent());\n  registry.register(new ExecutorAgent());\n  registry.register(new CodeReviewerAgent());\n  registry.register(new DocWriterAgent());\n}\n", "import type { AgentName, AgentResult, BackgroundTask, TaskStatus } from \"./types\";\nimport { getAgentRegistry } from \"./registry\";\n\nexport interface ISpawnInput {\n  sessionId: string;\n  agent: AgentName;\n  prompt: string;\n  description: string;\n}\n\nexport interface IBackgroundManager {\n  spawn(input: ISpawnInput): Promise<string>;\n  getStatus(taskId: string): Promise<BackgroundTask | null>;\n  cancel(taskId: string): Promise<boolean>;\n  getOutput(taskId: string, wait?: boolean): Promise<AgentResult | null>;\n  listTasks(sessionId?: string): BackgroundTask[];\n  cleanup(sessionId: string): void;\n}\n\ninterface SpawnInput {\n  sessionId: string;\n  agent: AgentName;\n  prompt: string;\n  description: string;\n}\n\nclass BackgroundManager implements IBackgroundManager {\n  private tasks: Map<string, BackgroundTask> = new Map();\n  private concurrencyLimits: Map<string, number> = new Map([\n    [\"default\", 3],\n    [\"anthropic\", 2],\n    [\"openai\", 3],\n    [\"google\", 5],\n  ]);\n  private runningCounts: Map<string, number> = new Map();\n  private queue: Array<{ task: BackgroundTask; provider: string }> = [];\n\n  async spawn(input: SpawnInput): Promise<string> {\n    const taskId = crypto.randomUUID();\n\n    const task: BackgroundTask = {\n      id: taskId,\n      sessionId: input.sessionId,\n      agent: input.agent,\n      prompt: input.prompt,\n      description: input.description,\n      status: \"pending\",\n      progress: { step: 0, total: 1, message: \"Queued\" },\n      startedAt: new Date(),\n    };\n\n    this.tasks.set(taskId, task);\n\n    const provider = this.getProviderForAgent(input.agent);\n    if (this.canRun(provider)) {\n      this.runTask(task);\n    } else {\n      this.queue.push({ task, provider });\n    }\n\n    return taskId;\n  }\n\n  private async runTask(task: BackgroundTask): Promise<void> {\n    const provider = this.getProviderForAgent(task.agent);\n    this.incrementRunning(provider);\n\n    task.status = \"in_progress\";\n    task.progress.message = \"Executing...\";\n\n    try {\n      const registry = getAgentRegistry();\n      const agent = registry.get(task.agent);\n\n      if (!agent) {\n        throw new Error(`Agent not found: ${task.agent}`);\n      }\n\n      const result = await agent.execute(task.prompt);\n\n      task.status = \"completed\";\n      task.result = result;\n      task.completedAt = new Date();\n      task.progress = { step: 1, total: 1, message: \"Completed\" };\n    } catch (error) {\n      task.status = \"failed\";\n      task.error = (error as Error).message;\n      task.completedAt = new Date();\n    } finally {\n      this.decrementRunning(provider);\n      this.processQueue();\n    }\n  }\n\n  async getStatus(taskId: string): Promise<BackgroundTask | null> {\n    return this.tasks.get(taskId) || null;\n  }\n\n  async cancel(taskId: string): Promise<boolean> {\n    const task = this.tasks.get(taskId);\n    if (!task || task.status === \"completed\") {\n      return false;\n    }\n\n    task.status = \"cancelled\";\n    task.completedAt = new Date();\n    return true;\n  }\n\n  async getOutput(taskId: string, wait: boolean = false): Promise<AgentResult | null> {\n    const task = this.tasks.get(taskId);\n    if (!task) return null;\n\n    if (wait && task.status === \"in_progress\") {\n      await this.waitForCompletion(taskId);\n    }\n\n    return task.result || null;\n  }\n\n  listTasks(sessionId?: string): BackgroundTask[] {\n    const tasks = Array.from(this.tasks.values());\n    if (sessionId) {\n      return tasks.filter((t) => t.sessionId === sessionId);\n    }\n    return tasks;\n  }\n\n  cleanup(sessionId: string): void {\n    for (const [id, task] of this.tasks) {\n      if (task.sessionId === sessionId) {\n        if (task.status === \"in_progress\") {\n          task.status = \"cancelled\";\n        }\n        this.tasks.delete(id);\n      }\n    }\n  }\n\n  private getProviderForAgent(agent: AgentName): string {\n    const providerMap: Record<AgentName, string> = {\n      coin: \"anthropic\",\n      analyst: \"google\",\n      executor: \"openai\",\n      code_reviewer: \"anthropic\",\n      doc_writer: \"google\",\n      explorer: \"anthropic\",\n    };\n    return providerMap[agent] || \"default\";\n  }\n\n  private canRun(provider: string): boolean {\n    const limit = this.concurrencyLimits.get(provider) || this.concurrencyLimits.get(\"default\") || 3;\n    const running = this.runningCounts.get(provider) || 0;\n    return running < limit;\n  }\n\n  private incrementRunning(provider: string): void {\n    const current = this.runningCounts.get(provider) || 0;\n    this.runningCounts.set(provider, current + 1);\n  }\n\n  private decrementRunning(provider: string): void {\n    const current = this.runningCounts.get(provider) || 0;\n    this.runningCounts.set(provider, Math.max(0, current - 1));\n  }\n\n  private processQueue(): void {\n    const toRun: Array<{ task: BackgroundTask; provider: string }> = [];\n\n    for (let i = this.queue.length - 1; i >= 0; i--) {\n      const item = this.queue[i];\n      if (this.canRun(item.provider)) {\n        toRun.push(item);\n        this.queue.splice(i, 1);\n      }\n    }\n\n    for (const item of toRun) {\n      this.runTask(item.task);\n    }\n  }\n\n  private async waitForCompletion(taskId: string, timeoutMs: number = 60000): Promise<void> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeoutMs) {\n      const task = this.tasks.get(taskId);\n      if (!task || task.status === \"completed\" || task.status === \"failed\" || task.status === \"cancelled\") {\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n\n    throw new Error(`Timeout waiting for task ${taskId}`);\n  }\n}\n\nlet backgroundManagerInstance: BackgroundManager | null = null;\n\nexport function getBackgroundManager(): IBackgroundManager {\n  if (!backgroundManagerInstance) {\n    backgroundManagerInstance = new BackgroundManager();\n  }\n  return backgroundManagerInstance;\n}\n", "import { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport type { LanguageModel } from \"ai\";\nimport type {\n  AISDKProviderName,\n  AISDKProviderConfig,\n  AISDKModelConfig,\n  AISDKModelResult,\n  ProviderRegistry,\n} from \"./types\";\n\nconst PROVIDER_REGISTRY: ProviderRegistry = {\n  anthropic: {\n    name: \"Claude (Anthropic)\",\n    requiresAuth: true,\n    supportsStreaming: true,\n    defaultModel: \"claude-sonnet-4-5\",\n  },\n  openai: {\n    name: \"OpenAI\",\n    requiresAuth: true,\n    supportsStreaming: true,\n    defaultModel: \"gpt-4o\",\n  },\n  google: {\n    name: \"Gemini (Google)\",\n    requiresAuth: true,\n    supportsStreaming: true,\n    defaultModel: \"gemini-2.0-flash\",\n  },\n  ollama: {\n    name: \"Ollama (Localhost)\",\n    requiresAuth: false,\n    supportsStreaming: true,\n    defaultBaseURL: \"http://localhost:11434/v1\",\n    defaultModel: \"llama3.2\",\n  },\n  lmstudio: {\n    name: \"LM Studio (Localhost)\",\n    requiresAuth: false,\n    supportsStreaming: true,\n    defaultBaseURL: \"http://localhost:1234/v1\",\n    defaultModel: \"local-model\",\n  },\n  llamacpp: {\n    name: \"llama.cpp (Localhost)\",\n    requiresAuth: false,\n    supportsStreaming: true,\n    defaultBaseURL: \"http://localhost:8080/v1\",\n    defaultModel: \"local-model\",\n  },\n};\n\nexport function getProviderConfig(provider: AISDKProviderName): AISDKProviderConfig {\n  const config = PROVIDER_REGISTRY[provider];\n  if (!config) {\n    throw new Error(`Unknown provider: ${provider}`);\n  }\n  return config;\n}\n\nexport function isLocalhostProvider(provider: AISDKProviderName): boolean {\n  return provider === \"ollama\" || provider === \"lmstudio\" || provider === \"llamacpp\";\n}\n\nexport function createModel(config: AISDKModelConfig): AISDKModelResult {\n  const providerConfig = getProviderConfig(config.provider);\n  const model = config.model || providerConfig.defaultModel;\n\n  let languageModel: LanguageModel;\n\n  switch (config.provider) {\n    case \"anthropic\": {\n      if (!config.apiKey) {\n        throw new Error(\"API key required for Anthropic\");\n      }\n      const anthropic = createAnthropic({ apiKey: config.apiKey });\n      languageModel = anthropic(model);\n      break;\n    }\n    case \"google\": {\n      if (!config.apiKey) {\n        throw new Error(\"API key required for Google\");\n      }\n      const google = createGoogleGenerativeAI({ apiKey: config.apiKey });\n      languageModel = google(model);\n      break;\n    }\n    case \"openai\": {\n      if (!config.apiKey) {\n        throw new Error(\"API key required for OpenAI\");\n      }\n      const openai = createOpenAI({ apiKey: config.apiKey });\n      languageModel = openai(model);\n      break;\n    }\n    case \"ollama\": {\n      const baseURL = config.baseURL || providerConfig.defaultBaseURL;\n      const ollama = createOpenAI({ baseURL, apiKey: \"ollama\" });\n      languageModel = ollama.chat(model);\n      break;\n    }\n    case \"lmstudio\": {\n      const baseURL = config.baseURL || providerConfig.defaultBaseURL;\n      const lmstudio = createOpenAI({ baseURL, apiKey: \"lm-studio\" });\n      languageModel = lmstudio.chat(model);\n      break;\n    }\n    case \"llamacpp\": {\n      const baseURL = config.baseURL || providerConfig.defaultBaseURL;\n      const llamacpp = createOpenAI({ baseURL, apiKey: \"llamacpp\" });\n      languageModel = llamacpp.chat(model);\n      break;\n    }\n    default: {\n      const _exhaustive: never = config.provider;\n      throw new Error(`Unhandled provider: ${_exhaustive}`);\n    }\n  }\n\n  return {\n    model: languageModel,\n    config: providerConfig,\n  };\n}\n\nexport function listProviders(): AISDKProviderConfig[] {\n  return Object.values(PROVIDER_REGISTRY);\n}\n\nexport function listLocalhostProviders(): AISDKProviderConfig[] {\n  return Object.entries(PROVIDER_REGISTRY)\n    .filter(([key]) => isLocalhostProvider(key as AISDKProviderName))\n    .map(([, config]) => config);\n}\n\nexport { PROVIDER_REGISTRY };\n", "import { streamText } from \"ai\";\nimport { createModel, isLocalhostProvider, getProviderConfig } from \"./registry\";\nimport { TokenStore } from \"../../../server/store/token-store\";\nimport type { AISDKProviderName, StreamOptions, StreamResult } from \"./types\";\nimport type { AuthProviderName } from \"../../auth/types\";\n\nconst AUTH_PROVIDER_MAP: Record<AISDKProviderName, AuthProviderName | null> = {\n  anthropic: \"claude\",\n  openai: \"codex\",\n  google: \"gemini\",\n  ollama: null,\n  lmstudio: null,\n  llamacpp: null,\n};\n\nfunction mapToAuthProvider(provider: AISDKProviderName): AuthProviderName | null {\n  return AUTH_PROVIDER_MAP[provider];\n}\n\nasync function getApiKey(\n  provider: AISDKProviderName,\n  accountId?: string\n): Promise<string | undefined> {\n  if (isLocalhostProvider(provider)) {\n    return undefined;\n  }\n\n  const authProvider = mapToAuthProvider(provider);\n  if (!authProvider) {\n    return undefined;\n  }\n\n  const tokenStore = new TokenStore();\n  const token = await tokenStore.retrieve(authProvider, accountId);\n  \n  if (!token) {\n    throw new Error(\n      `No authentication found for ${provider}. Run: supercoin auth login ${authProvider}`\n    );\n  }\n\n  return token.accessToken;\n}\n\ntype MessageRole = \"user\" | \"assistant\" | \"system\";\n\ninterface SimpleMessage {\n  role: MessageRole;\n  content: string;\n}\n\nfunction convertMessages(\n  messages: StreamOptions[\"messages\"],\n  systemPrompt?: string\n): SimpleMessage[] {\n  const result: SimpleMessage[] = [];\n\n  if (systemPrompt) {\n    result.push({ role: \"system\", content: systemPrompt });\n  }\n\n  for (const msg of messages) {\n    result.push({\n      role: msg.role,\n      content: msg.content,\n    });\n  }\n\n  return result;\n}\n\nfunction mapFinishReason(reason: string | null | undefined): StreamResult[\"finishReason\"] {\n  switch (reason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"tool-calls\":\n      return \"tool-calls\";\n    case \"error\":\n      return \"error\";\n    default:\n      return \"other\";\n  }\n}\n\nexport async function streamAIResponse(options: StreamOptions): Promise<StreamResult> {\n  const {\n    provider,\n    model,\n    messages,\n    systemPrompt,\n    accountId,\n    baseURL,\n    temperature = 0.7,\n    maxTokens = 4096,\n    onChunk,\n    onComplete,\n    onError,\n  } = options;\n\n  try {\n    const providerConfig = getProviderConfig(provider);\n    const apiKey = await getApiKey(provider, accountId);\n\n    const { model: languageModel } = createModel({\n      provider,\n      model: model || providerConfig.defaultModel,\n      apiKey,\n      baseURL,\n    });\n\n    const convertedMessages = convertMessages(messages, systemPrompt);\n\n    const result = await streamText({\n      model: languageModel,\n      messages: convertedMessages,\n      temperature,\n      maxOutputTokens: maxTokens,\n    });\n\n    let fullText = \"\";\n\n    for await (const chunk of result.textStream) {\n      fullText += chunk;\n      onChunk?.(chunk);\n    }\n\n    onComplete?.(fullText);\n\n    const usage = await result.usage;\n    const finishReason = await result.finishReason;\n\n    return {\n      text: fullText,\n      usage: usage\n        ? {\n            promptTokens: (usage as { promptTokens?: number }).promptTokens ?? 0,\n            completionTokens: (usage as { completionTokens?: number }).completionTokens ?? 0,\n            totalTokens: ((usage as { promptTokens?: number }).promptTokens ?? 0) + \n                         ((usage as { completionTokens?: number }).completionTokens ?? 0),\n          }\n        : undefined,\n      finishReason: mapFinishReason(finishReason),\n    };\n  } catch (error) {\n    const err = error instanceof Error ? error : new Error(String(error));\n    onError?.(err);\n    throw err;\n  }\n}\n\nexport async function generateAIResponse(\n  options: Omit<StreamOptions, \"onChunk\" | \"onComplete\" | \"onError\">\n): Promise<StreamResult> {\n  return streamAIResponse({\n    ...options,\n    onChunk: undefined,\n    onComplete: undefined,\n    onError: undefined,\n  });\n}\n\nexport async function checkLocalhostAvailability(\n  provider: \"ollama\" | \"lmstudio\" | \"llamacpp\",\n  baseURL?: string\n): Promise<boolean> {\n  const config = getProviderConfig(provider);\n  const url = baseURL || config.defaultBaseURL;\n\n  if (!url) {\n    return false;\n  }\n\n  try {\n    const response = await fetch(`${url}/models`, {\n      method: \"GET\",\n      signal: AbortSignal.timeout(3000),\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nexport async function listLocalhostModels(\n  provider: \"ollama\" | \"lmstudio\" | \"llamacpp\",\n  baseURL?: string\n): Promise<Array<{ id: string; name: string }>> {\n  const config = getProviderConfig(provider);\n  const url = baseURL || config.defaultBaseURL;\n\n  if (!url) {\n    return [];\n  }\n\n  try {\n    const response = await fetch(`${url}/models`, {\n      method: \"GET\",\n      signal: AbortSignal.timeout(5000),\n    });\n\n    if (!response.ok) {\n      return [];\n    }\n\n    const data = await response.json() as { data?: Array<{ id: string }> };\n    \n    return (data.data || []).map((model) => ({\n      id: model.id,\n      name: model.id,\n    }));\n  } catch {\n    return [];\n  }\n}\n", "import { z } from \"zod\";\nimport { readFile } from \"fs/promises\";\nimport { join } from \"path\";\nimport type { AISDKProviderName } from \"../services/models/ai-sdk/types\";\n\nconst OpenCodeConfigSchema = z.object({\n  provider: z.enum([\"anthropic\", \"openai\", \"google\", \"ollama\", \"lmstudio\", \"llamacpp\"]).default(\"ollama\"),\n  model: z.string().optional(),\n  baseURL: z.string().optional(),\n  temperature: z.number().min(0).max(2).default(0.7),\n  maxTokens: z.number().default(4096),\n  streaming: z.boolean().default(true),\n});\n\nexport type OpenCodeConfig = z.infer<typeof OpenCodeConfigSchema>;\n\nconst CONFIG_FILENAMES = [\"opencode.json\", \".opencode.json\", \"supercoin.json\"];\n\nexport async function loadOpenCodeConfig(cwd: string = process.cwd()): Promise<OpenCodeConfig> {\n  for (const filename of CONFIG_FILENAMES) {\n    try {\n      const configPath = join(cwd, filename);\n      const content = await readFile(configPath, \"utf-8\");\n      const parsed = JSON.parse(content);\n      return OpenCodeConfigSchema.parse(parsed);\n    } catch {\n      continue;\n    }\n  }\n\n  return OpenCodeConfigSchema.parse({});\n}\n\nexport function getDefaultProvider(): AISDKProviderName {\n  return \"ollama\";\n}\n\nexport function getDefaultModel(provider: AISDKProviderName): string {\n  const defaults: Record<AISDKProviderName, string> = {\n    anthropic: \"claude-sonnet-4-5\",\n    openai: \"gpt-4o\",\n    google: \"gemini-2.0-flash\",\n    ollama: \"llama3.2\",\n    lmstudio: \"local-model\",\n    llamacpp: \"local-model\",\n  };\n  return defaults[provider];\n}\n\nexport async function resolveProviderFromConfig(cwd?: string, mode: \"normal\" | \"ultrawork\" = \"normal\"): Promise<{\n  provider: AISDKProviderName;\n  model: string;\n  baseURL?: string;\n  temperature: number;\n  maxTokens: number;\n}> {\n  const config = await loadOpenCodeConfig(cwd);\n  \n  const provider = config.provider as AISDKProviderName;\n  let model = config.model || getDefaultModel(provider);\n  let temperature = config.temperature;\n  let maxTokens = config.maxTokens;\n\n  if (mode === \"ultrawork\") {\n    if (provider === \"anthropic\") model = \"claude-3-5-sonnet-latest\";\n    if (provider === \"openai\") model = \"gpt-4o\";\n    if (provider === \"google\") model = \"gemini-2.0-flash-exp\";\n    \n    temperature = 0.2;\n    maxTokens = 8192;\n  }\n\n  return {\n    provider,\n    model,\n    baseURL: config.baseURL,\n    temperature,\n    maxTokens,\n  };\n}\n", "import {\n  RequestType,\n  type Agent,\n  type AgentContext,\n  type AgentResult,\n  type AgentName,\n  type Task,\n  type ExecutionPlan,\n  type ExecutionResult,\n} from \"./types\";\nimport { getAgentRegistry } from \"./registry\";\nimport { streamAIResponse } from \"../models/ai-sdk\";\nimport { resolveProviderFromConfig } from \"../../config/opencode\";\nimport type { AISDKProviderName } from \"../models/ai-sdk/types\";\nimport { getTodoManager } from \"./todo-manager\";\nimport { getBackgroundManager } from \"./background\";\nimport { getSessionManager } from \"../../core/session\";\nimport { getHookRegistry } from \"../../core/hooks\";\nimport logger from \"../../shared/logger\";\n\nexport function classifyRequest(request: string): RequestType {\n  if (/ultrawork|ulw|\uC6B8\uD2B8\uB77C\uC6CC\uD06C/i.test(request)) {\n    return RequestType.COMPLEX;\n  }\n  // Complex patterns: multi-step tasks with \"and\" or \"then\"\n  if (/\\s+and\\s+(then\\s+)?/i.test(request) || /\\s+then\\s+/i.test(request)) {\n    return RequestType.COMPLEX;\n  }\n\n  // Exploratory patterns: questions about specific codebase elements\n  // Check BEFORE trivial, but be specific about codebase-related terms\n  const exploratoryPatterns = [\n    // \"How does the X module/component/service work?\" - codebase specific\n    /how\\s+(does|do|is|are)\\s+the\\s+\\w+\\s*(module|component|service|class|function|method|handler|controller|router|manager|provider)?\\s*(work|implemented|function)/i,\n    // \"Where is the X defined/located?\"\n    /where\\s+(is|are)\\s+(the\\s+)?\\w+\\s*(defined|located|used|found)/i,\n    // \"Find all X\"\n    /find\\s+(all|every|the)\\s+/i,\n    // \"What files/modules handle X?\"\n    /what\\s+(files?|modules?|functions?)\\s+(handle|contain|have)/i,\n  ];\n\n  for (const pattern of exploratoryPatterns) {\n    if (pattern.test(request)) return RequestType.EXPLORATORY;\n  }\n\n  // Open-ended patterns: improvement, refactoring, review tasks\n  const openEndedPatterns = [\n    /^(improve|optimize|refactor|enhance)/i,\n    /^(review|analyze|assess|evaluate)/i,\n    /make\\s+(it|this)\\s+(better|faster|cleaner)/i,\n  ];\n\n  for (const pattern of openEndedPatterns) {\n    if (pattern.test(request)) return RequestType.OPEN_ENDED;\n  }\n\n  // Explicit patterns: direct commands to run, build, create, etc.\n  const explicitPatterns = [\n    /^(run|execute|start|stop|build|test|deploy)/i,\n    /^(create|add|remove|delete|update)\\s+/i,\n    /^(install|uninstall)/i,\n    /^npm\\s+/i,\n    /^bun\\s+/i,\n  ];\n\n  for (const pattern of explicitPatterns) {\n    if (pattern.test(request)) return RequestType.EXPLICIT;\n  }\n\n  // Trivial patterns: simple questions, explanations\n  const trivialPatterns = [\n    /^(what|why|when)\\s+(is|are|do|does)/i,\n    /^(explain|describe|tell me about)/i,\n    /^(fix|correct)\\s+(this|the)\\s+(typo|error)/i,\n  ];\n\n  for (const pattern of trivialPatterns) {\n    if (pattern.test(request)) return RequestType.TRIVIAL;\n  }\n\n  return RequestType.TRIVIAL;\n}\n\nexport class Coin implements Agent {\n  readonly name = \"coin\" as const;\n  readonly displayName = \"Coin\";\n  readonly model = \"ollama/llama3:latest\";\n\n  readonly capabilities = [\n    \"planning\",\n    \"delegation\",\n    \"verification\",\n    \"coordination\",\n  ];\n\n  private readonly systemPrompt = `You are Coin, an AI orchestrator that coordinates multiple specialized agents to complete complex tasks.\n\n## Your Responsibilities\n1. Analyze user requests and classify their type\n2. Create execution plans with clear task breakdown\n3. Delegate tasks to appropriate specialized agents\n4. Monitor execution progress\n5. Verify results meet requirements\n6. Report final outcomes\n\n## Agent Catalog\n- analyst: Large codebase analysis, architecture review (Gemini - CHEAP)\n- executor: Command execution, build, deploy (GPT-4o - MEDIUM)\n- code_reviewer: Deep code review, security audit (Claude Opus - EXPENSIVE)\n- doc_writer: Documentation writing (Gemini Pro - CHEAP)\n- explorer: Codebase navigation, search (Haiku - FREE)\n\n## Delegation Rules\n- Use the cheapest agent that can handle the task\n- Use explorer for simple searches\n- Use analyst for large context analysis\n- Use code_reviewer only for critical reviews\n- Run independent tasks in parallel\n\n## Output Format\nProvide clear status updates and final summaries.`;\n\n  async execute(prompt: string, context?: AgentContext): Promise<AgentResult> {\n    const sessionId = context?.sessionId || \"default\";\n    const workdir = context?.workdir || process.cwd();\n    const todoManager = getTodoManager();\n    const sessionManager = getSessionManager();\n    const hookRegistry = getHookRegistry();\n    const classification = classifyRequest(prompt);\n\n    const isUltraWork = /ultrawork|ulw|\uC6B8\uD2B8\uB77C\uC6CC\uD06C/i.test(prompt);\n    const session = sessionManager.get(sessionId);\n    if (session) {\n      session.mode = isUltraWork ? \"ultrawork\" : \"normal\";\n      session.loop = {\n        iteration: 0,\n        maxIterations: isUltraWork ? 50 : 10,\n        stagnantCount: 0,\n      };\n    }\n\n    logger.debug(`Request classified as: ${classification} (ULW: ${isUltraWork})`);\n\n    try {\n      const mode = session?.mode || \"normal\";\n      if (mode === \"normal\" && (classification === RequestType.TRIVIAL || classification === RequestType.EXPLICIT)) {\n        const config = await resolveProviderFromConfig(workdir, mode);\n        const result = await streamAIResponse({\n          provider: config.provider as AISDKProviderName,\n          model: config.model,\n          temperature: config.temperature,\n          maxTokens: config.maxTokens,\n          messages: [{ role: \"user\", content: prompt }],\n          systemPrompt: this.systemPrompt,\n        });\n\n        return {\n          success: true,\n          content: result.text,\n          usage: result.usage,\n          model: `${config.provider}/${config.model}`,\n        };\n      }\n\n      const plan = await this.createPlan(prompt, classification);\n\n      for (const task of plan.tasks) {\n        await todoManager.create({\n          sessionId,\n          content: task.description,\n          priority: task.critical ? \"high\" : \"medium\",\n        });\n      }\n\n      let currentPrompt = prompt;\n      let finalContent = \"\";\n      let iterations = 0;\n      const maxIterations = session?.loop?.maxIterations || 10;\n\n      while (iterations < maxIterations) {\n        iterations++;\n        if (session?.loop) session.loop.iteration = iterations;\n\n        const results = await this.executePlan(plan, context);\n        finalContent += this.formatResults(plan, results) + \"\\n\";\n\n        const continuation = await hookRegistry.trigger(\"session.idle\", {\n          sessionId,\n          workdir,\n          event: \"session.idle\",\n          data: { iterations, classification, isUltraWork },\n        });\n\n        const result = continuation as any;\n        if (!result?.continue) {\n          break;\n        }\n\n        currentPrompt = result.prompt || currentPrompt;\n        logger.info(`Looping: iteration ${iterations}/${maxIterations}`);\n      }\n\n      return {\n        success: true,\n        content: finalContent || \"Tasks completed\",\n        model: \"ollama/llama3:latest\",\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n\n  private async createPlan(prompt: string, classification: RequestType): Promise<ExecutionPlan> {\n    const tasks: Task[] = [];\n\n    if (classification === RequestType.EXPLORATORY) {\n      tasks.push({\n        id: crypto.randomUUID(),\n        description: `Explore codebase for: ${prompt}`,\n        type: \"exploration\",\n        expectedOutcome: \"Search results with file locations\",\n        agent: \"explorer\",\n      });\n    } else if (classification === RequestType.OPEN_ENDED) {\n      tasks.push({\n        id: crypto.randomUUID(),\n        description: `Analyze and plan: ${prompt}`,\n        type: \"analysis\",\n        expectedOutcome: \"Analysis with recommendations\",\n        agent: \"analyst\",\n        runInBackground: true,\n      });\n    } else if (classification === RequestType.COMPLEX) {\n      tasks.push(\n        {\n          id: crypto.randomUUID(),\n          description: `Analyze requirements: ${prompt}`,\n          type: \"analysis\",\n          expectedOutcome: \"Detailed analysis\",\n          agent: \"analyst\",\n        },\n        {\n          id: crypto.randomUUID(),\n          description: `Execute implementation: ${prompt}`,\n          type: \"execution\",\n          expectedOutcome: \"Implementation complete\",\n          agent: \"executor\",\n          critical: true,\n        }\n      );\n    }\n\n    return { tasks, parallel: false };\n  }\n\n  private async executePlan(plan: ExecutionPlan, context?: AgentContext): Promise<ExecutionResult[]> {\n    const registry = getAgentRegistry();\n    const sessionId = context?.sessionId || \"default\";\n    const todoManager = getTodoManager();\n    const backgroundManager = getBackgroundManager();\n    const results: ExecutionResult[] = [];\n\n    for (const task of plan.tasks) {\n      const todos = todoManager.list(sessionId);\n      const todo = todos.find((t) => t.content === task.description);\n      if (todo) {\n        await todoManager.updateStatus(todo.id, \"in_progress\");\n      }\n\n      const agent = task.agent ? registry.get(task.agent) : undefined;\n\n      if (!agent) {\n        results.push({ success: false, error: `Agent not found: ${task.agent}` });\n        if (todo) {\n          await todoManager.updateStatus(todo.id, \"failed\");\n        }\n        continue;\n      }\n\n      if (task.runInBackground) {\n        const taskId = await backgroundManager.spawn({\n          sessionId: context?.sessionId || \"default\",\n          agent: task.agent!,\n          prompt: task.description,\n          description: task.description,\n        });\n        results.push({ success: true, taskId, pending: true });\n      } else {\n        const result = await agent.execute(task.description, context);\n        results.push({ success: result.success, error: result.error });\n\n        if (todo) {\n          await todoManager.updateStatus(todo.id, result.success ? \"completed\" : \"failed\");\n        }\n      }\n    }\n\n    return results;\n  }\n\n  private formatResults(plan: ExecutionPlan, results: ExecutionResult[]): string {\n    const lines: string[] = [\"## Execution Summary\\n\"];\n\n    for (let i = 0; i < plan.tasks.length; i++) {\n      const task = plan.tasks[i];\n      const result = results[i];\n\n      const status = result.success ? \"\u2713\" : \"\u2717\";\n      const pending = result.pending ? \" (background)\" : \"\";\n\n      lines.push(`${status} ${task.description}${pending}`);\n\n      if (result.error) {\n        lines.push(`  Error: ${result.error}`);\n      }\n    }\n\n    return lines.join(\"\\n\");\n  }\n}\n", "import type { Session, SessionMessage } from \"./types\";\n\nexport interface ISessionManager {\n  create(workdir: string, model: string): Session;\n  get(id: string): Session | undefined;\n  getCurrent(): Session | undefined;\n  setCurrent(id: string): boolean;\n  addMessage(sessionId: string, message: Omit<SessionMessage, \"timestamp\">): void;\n  getMessages(sessionId: string): SessionMessage[];\n  end(id: string): boolean;\n  list(): Session[];\n  clear(): void;\n}\n\nclass SessionManager implements ISessionManager {\n  private sessions: Map<string, Session> = new Map();\n  private currentSessionId: string | null = null;\n\n  create(workdir: string, model: string): Session {\n    const session: Session = {\n      id: crypto.randomUUID(),\n      startedAt: new Date(),\n      workdir,\n      model,\n      messages: [],\n    };\n\n    this.sessions.set(session.id, session);\n    this.currentSessionId = session.id;\n    return session;\n  }\n\n  get(id: string): Session | undefined {\n    return this.sessions.get(id);\n  }\n\n  getCurrent(): Session | undefined {\n    if (!this.currentSessionId) return undefined;\n    return this.sessions.get(this.currentSessionId);\n  }\n\n  setCurrent(id: string): boolean {\n    if (!this.sessions.has(id)) return false;\n    this.currentSessionId = id;\n    return true;\n  }\n\n  addMessage(sessionId: string, message: Omit<SessionMessage, \"timestamp\">): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.messages.push({\n        ...message,\n        timestamp: new Date(),\n      });\n    }\n  }\n\n  getMessages(sessionId: string): SessionMessage[] {\n    const session = this.sessions.get(sessionId);\n    return session?.messages || [];\n  }\n\n  end(id: string): boolean {\n    const session = this.sessions.get(id);\n    if (!session) return false;\n\n    if (this.currentSessionId === id) {\n      this.currentSessionId = null;\n    }\n\n    this.sessions.delete(id);\n    return true;\n  }\n\n  list(): Session[] {\n    return Array.from(this.sessions.values());\n  }\n\n  clear(): void {\n    this.sessions.clear();\n    this.currentSessionId = null;\n  }\n}\n\nlet sessionManagerInstance: SessionManager | null = null;\n\nexport function getSessionManager(): ISessionManager {\n  if (!sessionManagerInstance) {\n    sessionManagerInstance = new SessionManager();\n  }\n  return sessionManagerInstance;\n}\n", "import type { Agent, AgentContext, AgentResult } from \"./types\";\nimport { streamAIResponse } from \"../models/ai-sdk\";\n\nexport class ExplorerAgent implements Agent {\n  readonly name = \"explorer\" as const;\n  readonly displayName = \"Explorer\";\n  readonly model = \"ollama/llama3:latest\";\n\n  readonly capabilities = [\"exploration\", \"search\", \"navigation\"];\n\n  readonly allowedTools = [\n    \"grep\",\n    \"glob\",\n    \"read\",\n    \"lsp_find_references\",\n    \"lsp_goto_definition\",\n    \"lsp_workspace_symbols\",\n  ];\n\n  private readonly systemPrompt = `You are a fast codebase explorer. Your job is to quickly find information.\n\n## Approach\n1. Use grep for text search\n2. Use glob for file patterns\n3. Use lsp_* tools for semantic search\n4. Return results concisely\n\n## Output Format\nFound X results:\n1. file:line - brief description\n2. file:line - brief description\n...`;\n\n  async execute(prompt: string, _context?: AgentContext): Promise<AgentResult> {\n    try {\n      const result = await streamAIResponse({\n        provider: \"ollama\",\n        model: \"llama3:latest\",\n        messages: [{ role: \"user\", content: prompt }],\n        systemPrompt: this.systemPrompt,\n        temperature: 0.1,\n        maxTokens: 4096,\n      });\n\n      return {\n        success: true,\n        content: result.text,\n        usage: result.usage,\n        model: \"ollama/llama3:latest\",\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n", "import type { Agent, AgentContext, AgentResult } from \"./types\";\nimport { streamAIResponse } from \"../models/ai-sdk\";\n\nexport class AnalystAgent implements Agent {\n  readonly name = \"analyst\" as const;\n  readonly displayName = \"Analyst\";\n  readonly model = \"ollama/llama3:latest\";\n\n  readonly capabilities = [\n    \"large_context_analysis\",\n    \"code_review\",\n    \"architecture_analysis\",\n    \"security_audit\",\n  ];\n\n  readonly allowedTools = [\"read\", \"grep\", \"glob\"];\n\n  private readonly systemPrompt = `You are a specialized code analyst with expertise in:\n- Large-scale codebase analysis (1M+ tokens)\n- Architecture assessment and documentation\n- Performance profiling and optimization suggestions\n- Security vulnerability detection\n- Dependency analysis and upgrade paths\n\n## Approach\n1. Start with high-level overview\n2. Identify patterns and anti-patterns\n3. Provide actionable insights with file:line references\n4. Prioritize findings by impact\n\n## Output Format\nAlways structure your analysis as:\n- Executive Summary (2-3 sentences)\n- Key Findings (bullet points)\n- Detailed Analysis (by category)\n- Recommendations (prioritized)`;\n\n  async execute(prompt: string, _context?: AgentContext): Promise<AgentResult> {\n    try {\n      const result = await streamAIResponse({\n        provider: \"ollama\",\n        model: \"llama3:latest\",\n        messages: [{ role: \"user\", content: prompt }],\n        systemPrompt: this.systemPrompt,\n        temperature: 0.3,\n        maxTokens: 8192,\n      });\n\n      return {\n        success: true,\n        content: result.text,\n        usage: result.usage,\n        model: \"ollama/llama3:latest\",\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n", "import type { Agent, AgentContext, AgentResult } from \"./types\";\nimport { streamAIResponse } from \"../models/ai-sdk\";\n\nexport class ExecutorAgent implements Agent {\n  readonly name = \"executor\" as const;\n  readonly displayName = \"Executor\";\n  readonly model = \"ollama/llama3:latest\";\n\n  readonly capabilities = [\n    \"command_execution\",\n    \"build_automation\",\n    \"test_execution\",\n    \"deployment\",\n  ];\n\n  readonly allowedTools = [\n    \"bash\",\n    \"interactive_bash\",\n    \"read\",\n    \"write\",\n    \"grep\",\n    \"glob\",\n  ];\n\n  private readonly systemPrompt = `You are a command execution specialist with expertise in:\n- Shell command execution and scripting\n- Build systems (npm, yarn, bun, make, gradle, cargo)\n- Test runners and CI/CD pipelines\n- Docker and container operations\n- Git operations and version control\n\n## Approach\n1. Validate command safety before execution\n2. Execute commands in proper sequence\n3. Capture and report all output\n4. Handle errors gracefully\n\n## Safety Rules\n- NEVER execute destructive commands without confirmation\n- NEVER expose secrets or credentials in output\n- ALWAYS validate paths before file operations\n- ALWAYS use --dry-run where available first\n\n## Output Format\n\\`\\`\\`\nCommand: <executed command>\nExit Code: <0 or error code>\nOutput:\n<stdout/stderr>\n\nResult: SUCCESS | FAILURE\n\\`\\`\\``;\n\n  async execute(prompt: string, _context?: AgentContext): Promise<AgentResult> {\n    try {\n      const result = await streamAIResponse({\n        provider: \"ollama\",\n        model: \"llama3:latest\",\n        messages: [{ role: \"user\", content: prompt }],\n        systemPrompt: this.systemPrompt,\n        temperature: 0.1,\n        maxTokens: 4096,\n      });\n\n      return {\n        success: true,\n        content: result.text,\n        usage: result.usage,\n        model: \"ollama/llama3:latest\",\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n", "import type { Agent, AgentContext, AgentResult } from \"./types\";\nimport { streamAIResponse } from \"../models/ai-sdk\";\n\nexport class CodeReviewerAgent implements Agent {\n  readonly name = \"code_reviewer\" as const;\n  readonly displayName = \"Code Reviewer\";\n  readonly model = \"ollama/llama3:latest\";\n\n  readonly capabilities = [\n    \"code_review\",\n    \"security_analysis\",\n    \"performance_review\",\n    \"bug_detection\",\n  ];\n\n  readonly allowedTools = [\"read\", \"grep\"];\n\n  private readonly systemPrompt = `You are an expert code reviewer with decades of experience in:\n- Software design patterns and anti-patterns\n- Code quality and maintainability\n- Security vulnerabilities and best practices\n- Performance optimization\n- Testing strategies\n\n## Review Process\n1. **First Pass**: Overall structure and design\n2. **Second Pass**: Logic and correctness\n3. **Third Pass**: Security and edge cases\n4. **Fourth Pass**: Performance and optimization\n5. **Fifth Pass**: Style and consistency\n\n## Severity Levels\n- \uD83D\uDD34 CRITICAL: Must fix before merge (security, data loss, crashes)\n- \uD83D\uDFE0 MAJOR: Should fix (bugs, significant issues)\n- \uD83D\uDFE1 MINOR: Consider fixing (code quality, style)\n- \uD83D\uDFE2 NIT: Optional (preferences, suggestions)\n\n## Output Format\nFor each issue:\n\\`\\`\\`\n[SEVERITY] file:line\nDescription: <what's wrong>\nSuggestion: <how to fix>\nExample: <code snippet>\n\\`\\`\\``;\n\n  async execute(prompt: string, _context?: AgentContext): Promise<AgentResult> {\n    try {\n      const result = await streamAIResponse({\n        provider: \"ollama\",\n        model: \"llama3:latest\",\n        messages: [{ role: \"user\", content: prompt }],\n        systemPrompt: this.systemPrompt,\n        temperature: 0.2,\n        maxTokens: 8192,\n      });\n\n      return {\n        success: true,\n        content: result.text,\n        usage: result.usage,\n        model: \"ollama/llama3:latest\",\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n", "import type { Agent, AgentContext, AgentResult } from \"./types\";\nimport { streamAIResponse } from \"../models/ai-sdk\";\n\nexport class DocWriterAgent implements Agent {\n  readonly name = \"doc_writer\" as const;\n  readonly displayName = \"Documentation Writer\";\n  readonly model = \"ollama/llama3:latest\";\n\n  readonly capabilities = [\n    \"documentation\",\n    \"api_docs\",\n    \"readme\",\n    \"guides\",\n  ];\n\n  readonly allowedTools = [\"read\", \"write\", \"grep\", \"glob\"];\n\n  private readonly systemPrompt = `You are a technical documentation specialist with expertise in:\n- API documentation (OpenAPI, JSDoc, TSDoc)\n- README files and project documentation\n- User guides and tutorials\n- Architecture documentation\n- Changelog and release notes\n\n## Approach\n1. Analyze the codebase structure\n2. Identify documentation gaps\n3. Write clear, concise documentation\n4. Include code examples where appropriate\n\n## Documentation Standards\n- Use clear, simple language\n- Include examples for complex concepts\n- Structure content with headings and lists\n- Add cross-references where helpful\n\n## Output Format\nProvide documentation in Markdown format with proper headings, code blocks, and formatting.`;\n\n  async execute(prompt: string, _context?: AgentContext): Promise<AgentResult> {\n    try {\n      const result = await streamAIResponse({\n        provider: \"ollama\",\n        model: \"llama3:latest\",\n        messages: [{ role: \"user\", content: prompt }],\n        systemPrompt: this.systemPrompt,\n        temperature: 0.5,\n        maxTokens: 8192,\n      });\n\n      return {\n        success: true,\n        content: result.text,\n        usage: result.usage,\n        model: \"ollama/llama3:latest\",\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n", "export * from \"./types\";\nexport { getHookRegistry, type IHookRegistry } from \"./hooks\";\nexport { getToolRegistry, type IToolRegistry } from \"./tools\";\nexport { getSessionManager, type ISessionManager } from \"./session\";\nexport { initializeHooks } from \"./hooks/index\";\nexport { initializeTools } from \"./tools/index\";\n\nexport function initializeCore(): void {\n  const { initializeHooks } = require(\"./hooks/index\");\n  const { initializeTools } = require(\"./tools/index\");\n\n  initializeHooks();\n  initializeTools();\n}\n", "import { getAuthHub, AuthHub } from \"./services/auth/hub\";\nimport { getModelRouter, ModelRouter } from \"./services/models/router\";\nimport {\n  initializeAgents,\n  getAgentRegistry,\n  getTodoManager,\n  getBackgroundManager,\n} from \"./services/agents\";\nimport type { IAgentRegistry, ITodoManager, IBackgroundManager, ISpawnInput } from \"./services/agents\";\nimport { initializeCore, getSessionManager, getHookRegistry, getToolRegistry } from \"./core\";\nimport type { ISessionManager, IHookRegistry, IToolRegistry } from \"./core\";\nimport type { SuperCoinConfig } from \"./config/schema\";\nimport logger from \"./shared/logger\";\n\nexport interface SuperCoinOptions {\n  config: SuperCoinConfig;\n  workdir?: string;\n}\n\nexport class SuperCoin {\n  private config: SuperCoinConfig;\n  private workdir: string;\n  private initialized = false;\n\n  private _auth: AuthHub | null = null;\n  private _models: ModelRouter | null = null;\n\n  constructor(options: SuperCoinOptions) {\n    this.config = options.config;\n    this.workdir = options.workdir || process.cwd();\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    initializeCore();\n    initializeAgents();\n\n    this.initialized = true;\n    logger.debug(\"SuperCoin initialized\");\n  }\n\n  get auth(): AuthHub {\n    if (!this._auth) {\n      this._auth = getAuthHub();\n    }\n    return this._auth;\n  }\n\n  get models(): ModelRouter {\n    if (!this._models) {\n      this._models = getModelRouter({\n        defaultModel: this.config.default_model,\n        fallbackModels: this.config.fallback_models,\n      });\n    }\n    return this._models;\n  }\n\n  getAgents(): IAgentRegistry {\n    return getAgentRegistry();\n  }\n\n  getTodos(): ITodoManager {\n    return getTodoManager();\n  }\n\n  getBackground(): IBackgroundManager {\n    return getBackgroundManager();\n  }\n\n  getSessions(): ISessionManager {\n    return getSessionManager();\n  }\n\n  getHooks(): IHookRegistry {\n    return getHookRegistry();\n  }\n\n  getTools(): IToolRegistry {\n    return getToolRegistry();\n  }\n\n  get agents() {\n    return this.getAgents();\n  }\n\n  get todos() {\n    return this.getTodos();\n  }\n\n  get background() {\n    return this.getBackground();\n  }\n\n  get sessions() {\n    return this.getSessions();\n  }\n\n  get hooks() {\n    return this.getHooks();\n  }\n\n  get tools() {\n    return this.getTools();\n  }\n\n  async chat(message: string, options?: { model?: string }): Promise<string> {\n    await this.initialize();\n\n    const router = this.models;\n\n    if (options?.model) {\n      await router.setModel(options.model);\n    }\n\n    const response = await router.route({\n      messages: [{ role: \"user\", content: message }],\n    });\n\n    return response.content;\n  }\n\n  async runAgent(\n    agentName: \"coin\" | \"explorer\" | \"analyst\" | \"executor\" | \"code_reviewer\" | \"doc_writer\",\n    prompt: string\n  ): Promise<{ success: boolean; content?: string; error?: string }> {\n    await this.initialize();\n\n    const agent = this.getAgents().get(agentName);\n    if (!agent) {\n      return { success: false, error: `Agent not found: ${agentName}` };\n    }\n\n    const result = await agent.execute(prompt, {\n      sessionId: \"default\",\n      workdir: this.workdir,\n    });\n\n    return {\n      success: result.success,\n      content: result.content,\n      error: result.error,\n    };\n  }\n\n  async spawnBackground(\n    agentName: \"explorer\" | \"analyst\" | \"executor\" | \"code_reviewer\" | \"doc_writer\",\n    prompt: string,\n    description: string\n  ): Promise<string> {\n    await this.initialize();\n\n    const sessions = this.getSessions();\n    const session = sessions.getCurrent() || sessions.create(this.workdir, this.config.default_model);\n\n    const taskId = await this.getBackground().spawn({\n      sessionId: session.id,\n      agent: agentName,\n      prompt,\n      description,\n    });\n\n    return taskId;\n  }\n\n  async getBackgroundResult(taskId: string, wait = true): Promise<unknown> {\n    return this.getBackground().getOutput(taskId, wait);\n  }\n\n  createSession(): string {\n    const session = this.getSessions().create(this.workdir, this.config.default_model);\n    return session.id;\n  }\n\n  async executeTool(\n    toolName: string,\n    args: Record<string, unknown>\n  ): Promise<{ success: boolean; output?: string; error?: string }> {\n    await this.initialize();\n\n    const sessions = this.getSessions();\n    const session = sessions.getCurrent() || sessions.create(this.workdir, this.config.default_model);\n\n    const result = await this.getTools().execute(toolName, args, {\n      sessionId: session.id,\n      workdir: this.workdir,\n    });\n\n    return result;\n  }\n}\n\nexport function createSuperCoin(config: SuperCoinConfig, workdir?: string): SuperCoin {\n  return new SuperCoin({ config, workdir });\n}\n"],
  "mappings": "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",
  "names": ["init_hooks", "exec", "fs", "path", "fs", "path", "init_tools", "crypto", "filePath", "clack", "clack", "fs", "existsSync", "crypto", "path", "crypto", "resolve", "createServer", "serverInfo", "Hono", "Hono", "Hono", "callbackData", "resolve", "Hono", "Hono", "resolve", "resolve", "init_hooks", "init_tools", "initializeHooks", "initializeTools"]
}
